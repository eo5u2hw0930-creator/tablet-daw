
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#00ff88">
    <meta name="description" content="TabletDAW - Mobile Music Studio">
    
    <!-- PWA -->
    <link rel="manifest" href="manifest.json">
    
    <!-- iOS Support -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="TabletDAW">
    <link rel="apple-touch-icon" href="icons/icon-192.png">
    
    <!-- Android -->
    <meta name="mobile-web-app-capable" content="yes">
    
    <title>TabletDAW - Mobile Music Studio</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        :root {
            --bg-primary: #0a0a0f;
            --bg-secondary: #12121a;
            --bg-tertiary: #1a1a25;
            --bg-grid: #1a1a22;
            --accent-green: #00ff88;
            --accent-pink: #ff3399;
            --accent-cyan: #00d4ff;
            --accent-purple: #9966ff;
            --accent-orange: #ff6633;
            --accent-yellow: #ffcc00;
            --text-primary: #ffffff;
            --text-secondary: #8888aa;
            --border-color: #2a2a3a;
            --grid-line: rgba(255,255,255,0.06);
            --grid-line-bar: rgba(255,255,255,0.2);
            
            --cell-width: 25px;
            --cell-height: 18px;
            --beats-per-bar: 4;
            --bar-width: calc(var(--cell-width) * var(--beats-per-bar));
            --piano-width: 44px;
            --track-info-width: 100px;
            
            --safe-top: env(safe-area-inset-top);
            --safe-bottom: env(safe-area-inset-bottom);
            --safe-left: env(safe-area-inset-left);
            --safe-right: env(safe-area-inset-right);
        }

        body {
            font-family: 'JetBrains Mono', monospace;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
            height: 100dvh;
            width: 100vw;
            user-select: none;
            -webkit-user-select: none;
            padding: var(--safe-top) var(--safe-right) var(--safe-bottom) var(--safe-left);
        }

        /* Start Screen */
        .start-screen {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100%;
            width: 100%;
            background: var(--bg-primary);
            background-image: 
                radial-gradient(ellipse at 50% 0%, rgba(0,255,136,0.12) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 80%, rgba(153,102,255,0.1) 0%, transparent 40%),
                radial-gradient(ellipse at 20% 60%, rgba(255,51,153,0.08) 0%, transparent 40%);
            overflow: hidden;
        }

        .start-screen::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%23ffffff' fill-opacity='0.02'%3E%3Cpath d='M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zM6 34v-4H4v4H0v2h4v4h2v-4h4v-2H6zM6 4V0H4v4H0v2h4v4h2V6h4V4H6z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
            pointer-events: none;
        }

        .start-screen.hidden { display: none; }

        .start-icon {
            font-size: 80px;
            margin-bottom: 20px;
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .start-logo {
            font-size: clamp(36px, 10vw, 56px);
            font-weight: 700;
            background: linear-gradient(135deg, var(--accent-green), var(--accent-cyan), var(--accent-purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 8px;
            text-shadow: 0 0 60px rgba(0,255,136,0.5);
        }

        .start-subtitle {
            font-size: clamp(12px, 3vw, 14px);
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .start-version {
            font-size: 11px;
            color: var(--accent-green);
            background: rgba(0,255,136,0.1);
            padding: 4px 12px;
            border-radius: 12px;
            margin-bottom: 40px;
            font-weight: 600;
            border: 1px solid rgba(0,255,136,0.2);
        }

        .new-project-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            padding: 20px 50px;
            background: linear-gradient(135deg, var(--accent-green), var(--accent-cyan));
            border: none;
            border-radius: 16px;
            color: #000;
            font-family: 'JetBrains Mono', monospace;
            font-size: clamp(16px, 4vw, 20px);
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 8px 32px rgba(0,255,136,0.4);
        }

        .new-project-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 40px rgba(0,255,136,0.5);
        }

        .new-project-btn:active {
            transform: scale(0.95);
        }

        .new-project-btn span {
            font-size: 24px;
        }

        .install-hint {
            position: absolute;
            bottom: 20px;
            font-size: 11px;
            color: var(--text-secondary);
            text-align: center;
            padding: 0 20px;
        }

        /* App Container */
        .app-container {
            display: none;
            flex-direction: column;
            height: 100%;
            width: 100%;
        }

        .app-container.show { display: flex; }

        /* Toolbar */
        .toolbar {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 8px 10px;
            background: linear-gradient(180deg, var(--bg-secondary) 0%, var(--bg-primary) 100%);
            border-bottom: 2px solid var(--border-color);
            flex-shrink: 0;
            flex-wrap: wrap;
            min-height: 56px;
        }

        .toolbar-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 42px;
            height: 42px;
            padding: 0;
            background: linear-gradient(145deg, var(--bg-tertiary), var(--bg-primary));
            border: 1px solid var(--border-color);
            border-radius: 10px;
            color: var(--text-primary);
            font-size: 18px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .toolbar-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .toolbar-btn:active {
            transform: scale(0.92);
            box-shadow: 0 1px 4px rgba(0,0,0,0.2);
        }

        .toolbar-btn.play {
            background: linear-gradient(145deg, var(--accent-green), #00cc6a);
            color: #000;
            border: none;
            width: 50px;
            font-size: 20px;
        }

        .toolbar-btn.play.playing {
            background: linear-gradient(145deg, var(--accent-orange), #cc5522);
        }

        .toolbar-btn.stop {
            background: linear-gradient(145deg, var(--accent-pink), #cc2266);
            color: #fff;
            border: none;
        }

        .toolbar-btn.active {
            background: linear-gradient(145deg, var(--accent-cyan), #00aacc);
            color: #000;
            border: none;
            box-shadow: 0 0 15px rgba(0,212,255,0.4);
        }

        .bpm-control {
            display: flex;
            align-items: center;
            gap: 6px;
            background: var(--bg-tertiary);
            padding: 4px 8px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        .bpm-label {
            font-size: 9px;
            color: var(--accent-cyan);
            font-weight: 700;
            white-space: nowrap;
        }

        .bpm-input {
            width: 45px;
            padding: 4px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--accent-green);
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            font-weight: 700;
            text-align: center;
            -moz-appearance: textfield;
        }

        .bpm-input::-webkit-outer-spin-button,
        .bpm-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .track-selector {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .track-dropdown {
            padding: 8px 10px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            max-width: 100px;
        }

        .instrument-selector {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .instrument-dropdown {
            padding: 6px 8px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--accent-cyan);
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
        }

        .time-display {
            font-size: 12px;
            font-weight: 600;
            color: var(--accent-cyan);
            background: var(--bg-tertiary);
            padding: 6px 10px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            margin-left: auto;
        }

        /* Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.85);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .modal-overlay.show { display: flex; }

        .modal {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 20px;
            max-width: 350px;
            width: 100%;
        }

        .modal-title {
            font-size: 16px;
            font-weight: 700;
            margin-bottom: 10px;
            color: var(--accent-purple);
        }

        .modal-message {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 16px;
            line-height: 1.5;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .modal-btn {
            padding: 10px 16px;
            border-radius: 6px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            border: 1px solid var(--border-color);
        }

        .modal-btn.cancel {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .modal-btn.confirm {
            background: linear-gradient(135deg, var(--accent-green), var(--accent-cyan));
            color: #000;
            border: none;
        }

        /* Track Type Selection */
        .track-type-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }

        .track-type-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 10px;
            padding: 20px 16px;
            background: linear-gradient(145deg, var(--bg-tertiary), var(--bg-primary));
            border: 2px solid var(--border-color);
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .track-type-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at 50% 0%, rgba(255,255,255,0.1) 0%, transparent 60%);
            pointer-events: none;
        }

        .track-type-btn:active {
            transform: scale(0.95);
        }

        .track-type-btn.note-type {
            border-color: rgba(0,255,136,0.3);
        }
        .track-type-btn.note-type:hover,
        .track-type-btn.note-type:active {
            border-color: var(--accent-green);
            background: linear-gradient(145deg, rgba(0,255,136,0.2), rgba(0,255,136,0.05));
            box-shadow: 0 0 30px rgba(0,255,136,0.3);
        }

        .track-type-btn.drum-type {
            border-color: rgba(255,102,51,0.3);
        }
        .track-type-btn.drum-type:hover,
        .track-type-btn.drum-type:active {
            border-color: var(--accent-orange);
            background: linear-gradient(145deg, rgba(255,102,51,0.2), rgba(255,102,51,0.05));
            box-shadow: 0 0 30px rgba(255,102,51,0.3);
        }

        .track-type-btn.record-type {
            border-color: rgba(255,51,153,0.3);
        }
        .track-type-btn.record-type:hover,
        .track-type-btn.record-type:active {
            border-color: var(--accent-pink);
            background: linear-gradient(145deg, rgba(255,51,153,0.2), rgba(255,51,153,0.05));
            box-shadow: 0 0 30px rgba(255,51,153,0.3);
        }

        .track-type-btn.audio-type {
            border-color: rgba(0,212,255,0.3);
        }
        .track-type-btn.audio-type:hover,
        .track-type-btn.audio-type:active {
            border-color: var(--accent-cyan);
            background: linear-gradient(145deg, rgba(0,212,255,0.2), rgba(0,212,255,0.05));
            box-shadow: 0 0 30px rgba(0,212,255,0.3);
        }

        .track-type-icon {
            font-size: 40px;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));
        }

        .track-type-name {
            font-size: 12px;
            font-weight: 700;
            color: var(--text-primary);
        }

        .track-type-desc {
            font-size: 9px;
            color: var(--text-secondary);
        }

        /* New Modal Styles */
        .modal-input {
            width: 100%;
            padding: 12px;
            background: var(--bg-tertiary);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            margin-bottom: 16px;
        }

        .modal-input:focus {
            outline: none;
            border-color: var(--accent-cyan);
        }

        .modal-form {
            margin-bottom: 16px;
        }

        .save-options, .load-options {
            display: flex;
            gap: 12px;
            margin-bottom: 16px;
        }

        .save-option-btn, .load-option-btn {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            padding: 16px;
            background: var(--bg-tertiary);
            border: 2px solid var(--border-color);
            border-radius: 12px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .save-option-btn:hover, .load-option-btn:hover {
            border-color: var(--accent-green);
            background: rgba(0,255,136,0.1);
        }

        .save-option-btn span, .load-option-btn span {
            font-size: 24px;
        }

        .saved-projects, .saved-projects-list {
            max-height: 200px;
            overflow-y: auto;
            margin-bottom: 16px;
        }

        .saved-project-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .saved-project-item:hover {
            background: rgba(0,212,255,0.1);
        }

        .saved-project-name {
            font-weight: 600;
            color: var(--text-primary);
        }

        .saved-project-date {
            font-size: 10px;
            color: var(--text-secondary);
        }

        .saved-project-delete {
            padding: 4px 8px;
            background: var(--accent-pink);
            border: none;
            border-radius: 4px;
            color: #fff;
            cursor: pointer;
            font-size: 10px;
        }

        .settings-modal {
            max-width: 400px;
        }

        .settings-section {
            margin-bottom: 16px;
        }

        .settings-label {
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 6px;
        }

        .settings-select {
            width: 100%;
            padding: 10px;
            background: var(--bg-tertiary);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            cursor: pointer;
        }

        .settings-select:focus {
            outline: none;
            border-color: var(--accent-cyan);
        }

        .toolbar-divider {
            width: 1px;
            height: 24px;
            background: var(--border-color);
            margin: 0 4px;
        }

        /* Drum Track Styles */
        .drum-track-view {
            display: none;
            flex-direction: column;
            flex: 1;
            background: var(--bg-grid);
            border-left: 1px solid var(--border-color);
        }

        .drum-track-view.show {
            display: flex;
        }

        .drum-kit-header {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 10px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        .drum-kit-label {
            font-size: 16px;
        }

        .drum-kit-select {
            padding: 5px 8px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            flex: 1;
            max-width: 100px;
        }

        .drum-header-btn {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .drum-header-btn:active {
            transform: scale(0.9);
            background: var(--accent-orange);
        }

        .drum-tools {
            display: flex;
            gap: 4px;
            background: var(--bg-tertiary);
            padding: 3px;
            border-radius: 6px;
            margin-left: 8px;
        }

        .drum-tool-btn {
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: transparent;
            border: none;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .drum-tool-btn:hover {
            background: rgba(255,255,255,0.1);
        }

        .drum-tool-btn.active {
            background: linear-gradient(145deg, var(--accent-orange), #cc5522);
            box-shadow: 0 2px 8px rgba(255,102,51,0.4);
        }

        .drum-selection-box {
            position: absolute;
            border: 2px dashed var(--accent-orange);
            background: rgba(255, 102, 51, 0.15);
            pointer-events: none;
            z-index: 50;
            border-radius: 4px;
        }

        .drum-cell.selected {
            box-shadow: 0 0 0 2px #fff, 0 0 8px rgba(255,255,255,0.5);
        }

        .drum-timeline-wrapper {
            display: flex;
            height: 24px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
        }

        .drum-timeline-spacer {
            min-width: 80px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
        }

        .drum-timeline {
            flex: 1;
            display: flex;
            overflow-x: auto;
            overflow-y: hidden;
        }

        .drum-timeline::-webkit-scrollbar {
            display: none;
        }

        .drum-timeline-bar {
            display: flex;
            flex-shrink: 0;
        }

        .drum-timeline-beat {
            width: 112px;
            min-width: 112px;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            padding-left: 4px;
            font-size: 9px;
            color: var(--text-secondary);
            border-right: 1px solid var(--grid-line);
            box-sizing: border-box;
        }

        .drum-timeline-beat.bar-end {
            border-right: 2px solid var(--grid-line-bar);
        }

        .drum-timeline-beat.bar-first {
            color: var(--accent-orange);
            font-weight: 600;
        }

        .drum-grid-container {
            flex: 1;
            display: flex;
            overflow: auto;
        }

        .drum-labels {
            min-width: 80px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
        }

        .drum-label {
            height: 40px;
            display: flex;
            align-items: center;
            padding: 0 12px;
            font-size: 11px;
            font-weight: 600;
            color: var(--text-primary);
            border-bottom: 1px solid var(--grid-line);
            cursor: pointer;
            transition: all 0.2s;
            background: linear-gradient(90deg, var(--bg-secondary), transparent);
        }

        .drum-label:hover {
            background: linear-gradient(90deg, var(--bg-tertiary), transparent);
            padding-left: 16px;
        }

        .drum-label:active {
            background: linear-gradient(90deg, var(--accent-orange), transparent);
            color: #000;
        }

        .drum-grid-wrapper {
            flex: 1;
            overflow-x: auto;
            overflow-y: hidden;
            position: relative;
        }

        .drum-grid {
            display: flex;
            flex-direction: column;
            min-width: max-content;
        }

        .drum-row {
            display: flex;
            height: 40px;
            border-bottom: 1px solid var(--grid-line);
        }

        .drum-cell {
            width: 28px;
            min-width: 28px;
            height: 100%;
            border-right: 1px solid var(--grid-line);
            cursor: pointer;
            transition: all 0.15s;
            position: relative;
        }

        .drum-cell.beat-start {
            border-right: 2px solid var(--grid-line-bar);
        }

        .drum-cell:hover {
            background: rgba(255,102,51,0.3);
        }

        .drum-cell.active {
            background: linear-gradient(145deg, var(--accent-orange), #cc5522);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3), 0 0 10px rgba(255,102,51,0.4);
            border-radius: 4px;
            margin: 2px;
            width: 24px;
            min-width: 24px;
            height: calc(100% - 4px);
        }

        .drum-cell.playing {
            background: linear-gradient(145deg, var(--accent-yellow), #ccaa00);
            box-shadow: 0 0 15px rgba(255,204,0,0.6);
        }

        .drum-playhead {
            position: absolute;
            top: 0;
            width: 3px;
            height: 100%;
            background: linear-gradient(180deg, #ff3333, #ff6666);
            box-shadow: 0 0 12px #ff3333;
            z-index: 100;
            pointer-events: none;
        }

        /* Record Track Waveform Area */
        .record-track-view {
            display: none;
            flex-direction: column;
            flex: 1;
            background: var(--bg-grid);
            border-left: 1px solid var(--border-color);
        }

        .record-track-view.show {
            display: flex;
        }

        .record-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 14px;
            background: linear-gradient(180deg, var(--bg-secondary), var(--bg-primary));
            border-bottom: 2px solid var(--border-color);
        }

        .record-btn {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .record-btn:active {
            transform: scale(0.9);
        }

        .record-btn.rec {
            background: linear-gradient(145deg, var(--accent-pink), #cc2266);
            color: #fff;
            box-shadow: 0 4px 15px rgba(255,51,153,0.4);
        }

        .record-btn.rec.recording {
            animation: pulse 1s infinite;
        }

        .record-btn.stop-rec {
            background: linear-gradient(145deg, var(--bg-tertiary), var(--bg-primary));
            border: 2px solid var(--border-color);
            color: var(--text-primary);
        }

        .record-btn.stop-rec:hover {
            border-color: var(--accent-cyan);
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(255,51,153,0.7); }
            50% { transform: scale(1.1); box-shadow: 0 0 30px 10px rgba(255,51,153,0.4); }
        }

        .record-status {
            font-size: 11px;
            color: var(--text-secondary);
            font-weight: 600;
        }

        .record-status.recording {
            color: var(--accent-pink);
            font-weight: 700;
            text-shadow: 0 0 10px rgba(255,51,153,0.5);
        }

        .record-divider {
            width: 2px;
            height: 28px;
            background: linear-gradient(180deg, transparent, var(--border-color), transparent);
            margin: 0 6px;
        }

        .record-btn.edit-tool {
            width: 40px;
            height: 40px;
            background: linear-gradient(145deg, var(--bg-tertiary), var(--bg-primary));
            border: 2px solid var(--border-color);
            color: var(--text-primary);
            font-size: 16px;
        }

        .record-btn.edit-tool.active {
            background: linear-gradient(145deg, var(--accent-cyan), #00aacc);
            border-color: var(--accent-cyan);
            color: #000;
            box-shadow: 0 0 15px rgba(0,212,255,0.5);
        }

        .record-timeline-wrapper {
            height: 24px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            overflow-x: auto;
            overflow-y: hidden;
        }

        .record-timeline-wrapper::-webkit-scrollbar {
            display: none;
        }

        .record-timeline {
            display: flex;
            height: 100%;
            min-width: max-content;
        }

        .record-timeline-bar {
            display: flex;
            flex-shrink: 0;
        }

        .record-timeline-beat {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            padding-left: 4px;
            font-size: 9px;
            color: var(--text-secondary);
            border-right: 1px solid var(--grid-line);
            box-sizing: border-box;
        }

        .record-timeline-beat.bar-end {
            border-right: 2px solid var(--grid-line-bar);
        }

        .record-timeline-beat.bar-first {
            color: var(--accent-pink);
            font-weight: 600;
        }

        .waveform-container {
            flex: 1;
            position: relative;
            overflow: auto;
            -webkit-overflow-scrolling: touch;
        }

        .waveform-area {
            height: 100%;
            min-width: 100%;
            position: relative;
            background: var(--bg-grid);
        }

        .waveform-grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .clips-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* Audio Clip */
        .audio-clip {
            position: absolute;
            top: 10%;
            height: 80%;
            background: rgba(255, 51, 153, 0.2);
            border: 2px solid var(--accent-pink);
            border-radius: 4px;
            cursor: grab;
            overflow: hidden;
        }

        .audio-clip.selected {
            border-color: var(--accent-cyan);
            box-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
        }

        .audio-clip.dragging {
            cursor: grabbing;
            opacity: 0.8;
        }

        .audio-clip canvas {
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        /* Trim Handles */
        .clip-handle {
            position: absolute;
            top: 0;
            width: 12px;
            height: 100%;
            background: var(--accent-cyan);
            cursor: ew-resize;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 10;
        }

        .audio-clip:hover .clip-handle,
        .audio-clip.selected .clip-handle {
            opacity: 0.8;
        }

        .clip-handle.left {
            left: 0;
            border-radius: 4px 0 0 4px;
        }

        .clip-handle.right {
            right: 0;
            border-radius: 0 4px 4px 0;
        }

        .clip-handle:hover {
            opacity: 1;
        }

        /* Split Cursor */
        .split-cursor {
            position: absolute;
            top: 0;
            width: 2px;
            height: 100%;
            background: var(--accent-orange);
            pointer-events: none;
            display: none;
            z-index: 50;
        }

        .split-cursor::before {
            content: '✂️';
            position: absolute;
            top: -20px;
            left: -8px;
            font-size: 14px;
        }

        .waveform-area.split-mode {
            cursor: crosshair;
        }

        .waveform-area.split-mode .split-cursor {
            display: block;
        }

        .waveform-placeholder {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: var(--text-secondary);
        }

        .waveform-placeholder-icon {
            font-size: 48px;
            margin-bottom: 12px;
            opacity: 0.5;
        }

        .waveform-placeholder-text {
            font-size: 12px;
        }

        .record-playhead {
            position: absolute;
            top: 0;
            width: 2px;
            height: 100%;
            background: #ff3333;
            box-shadow: 0 0 8px #ff3333;
            z-index: 100;
            pointer-events: none;
        }

        /* Track type indicator */
        .track-type-indicator {
            font-size: 10px;
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
            flex-shrink: 0;
        }

        .track-type-indicator.note {
            background: var(--accent-green);
        }

        .track-type-indicator.record {
            background: var(--accent-pink);
        }

        .track-type-indicator.drum {
            background: var(--accent-orange);
        }

        /* Main Content */
        .main-content {
            display: flex;
            flex-direction: column;
            flex: 1;
            overflow: hidden;
        }

        /* Piano Roll */
        .piano-roll-section {
            display: flex;
            flex: 1;
            flex-direction: column;
            overflow: hidden;
        }

        .piano-roll-header {
            display: none;
            align-items: center;
            gap: 8px;
            padding: 6px 10px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
            overflow-x: auto;
            min-height: 44px;
        }

        .piano-roll-header.show {
            display: flex;
        }

        .piano-roll-label {
            font-size: 16px;
            flex-shrink: 0;
        }

        .instrument-dropdown-mini {
            padding: 5px 8px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            min-width: 80px;
            max-width: 120px;
            flex-shrink: 0;
        }

        .grid-select-mini {
            padding: 5px 8px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            min-width: 50px;
            max-width: 60px;
            flex-shrink: 0;
        }

        .note-tools {
            display: flex;
            gap: 4px;
            background: var(--bg-tertiary);
            padding: 3px;
            border-radius: 6px;
            flex-shrink: 0;
        }

        .note-tool-btn {
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: transparent;
            border: none;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .note-tool-btn:hover {
            background: rgba(255,255,255,0.1);
        }

        .note-tool-btn.active {
            background: linear-gradient(145deg, var(--accent-green), #22aa66);
            box-shadow: 0 2px 8px rgba(0,212,170,0.4);
        }

        .piano-roll-container {
            display: flex;
            flex: 1;
            overflow: hidden;
            position: relative;
        }

        .piano-roll-container.hidden {
            display: none;
        }

        /* Empty State */
        .empty-state {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: linear-gradient(180deg, rgba(26, 26, 34, 0.98), rgba(10, 10, 15, 0.98));
            z-index: 200;
        }

        .empty-state::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 300px;
            height: 300px;
            transform: translate(-50%, -50%);
            background: radial-gradient(circle, rgba(0,255,136,0.1) 0%, transparent 70%);
            pointer-events: none;
        }

        .empty-state.show {
            display: flex;
        }

        .empty-state-icon {
            font-size: 72px;
            margin-bottom: 20px;
            animation: float 3s ease-in-out infinite;
            filter: drop-shadow(0 10px 20px rgba(0,0,0,0.5));
        }

        .empty-state-title {
            font-size: 20px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 10px;
        }

        .empty-state-text {
            font-size: 13px;
            color: var(--text-secondary);
            text-align: center;
            line-height: 1.8;
            margin-bottom: 24px;
        }

        .empty-state-btn {
            padding: 14px 32px;
            background: linear-gradient(135deg, var(--accent-green), var(--accent-cyan));
            color: #000;
            border: none;
            border-radius: 12px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            box-shadow: 0 8px 25px rgba(0,255,136,0.3);
            transition: all 0.2s;
        }

        .empty-state-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 35px rgba(0,255,136,0.4);
        }

        .empty-state-btn:active {
            transform: scale(0.95);
        }

        /* Grid Resolution Select */
        .grid-select {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 4px 6px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: var(--accent-cyan);
            cursor: pointer;
        }

        /* Grid Lines */
        .grid-line {
            position: absolute;
            top: 0;
            width: 1px;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .grid-line.line-32 {
            background: rgba(255, 255, 255, 0.03);
        }

        .grid-line.line-16 {
            background: rgba(255, 255, 255, 0.06);
        }

        .grid-line.line-8 {
            background: rgba(255, 255, 255, 0.12);
        }

        .grid-line.line-beat {
            background: rgba(255, 255, 255, 0.2);
        }

        .grid-line.line-bar {
            background: rgba(255, 255, 255, 0.4);
            width: 2px;
        }

        /* Add Bar Button */
        .add-bar-btn {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 28px;
            height: 40px;
            background: var(--accent-green);
            color: #000;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: 700;
            cursor: pointer;
            z-index: 150;
            opacity: 0.8;
            transition: opacity 0.2s;
        }

        .add-bar-btn:hover {
            opacity: 1;
        }

        .piano-keys {
            display: flex;
            flex-direction: column;
            width: var(--piano-width);
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            flex-shrink: 0;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        .piano-keys::-webkit-scrollbar { display: none; }

        .piano-key {
            height: var(--cell-height);
            min-height: var(--cell-height);
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 4px;
            font-size: 8px;
            border-bottom: 1px solid rgba(0,0,0,0.3);
            cursor: pointer;
            flex-shrink: 0;
        }

        .piano-key.white {
            background: linear-gradient(90deg, #d0d0d0, #ffffff);
            color: #555;
        }

        .piano-key.black {
            background: linear-gradient(90deg, #1a1a1a, #2a2a2a);
            color: #777;
        }

        .piano-key.playing {
            background: var(--accent-green) !important;
            color: #000 !important;
        }

        /* Timeline */
        .timeline-wrapper {
            display: flex;
            height: 22px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        .timeline-spacer {
            width: var(--piano-width);
            flex-shrink: 0;
            border-right: 1px solid var(--border-color);
        }

        .timeline {
            flex: 1;
            overflow: hidden;
            position: relative;
        }

        .timeline-inner {
            display: flex;
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
        }

        .timeline-beat {
            font-size: 9px;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            padding-left: 4px;
            border-right: 1px solid var(--grid-line);
            box-sizing: border-box;
        }

        .timeline-beat.bar-end {
            border-right: 2px solid var(--grid-line-bar);
        }

        .timeline-beat.bar-first {
            color: var(--accent-green);
            font-weight: 600;
        }

        /* Grid */
        .piano-grid-wrapper {
            flex: 1;
            overflow: auto;
            -webkit-overflow-scrolling: touch;
        }

        .piano-grid {
            position: relative;
            background: linear-gradient(180deg, var(--bg-grid) 0%, rgba(10,10,15,1) 100%);
        }

        .grid-row {
            display: flex;
            height: var(--cell-height);
        }

        .grid-row.black-key { background: rgba(0,0,0,0.4); }
        .grid-row.c-note { border-bottom: 2px solid var(--grid-line-bar); }

        .grid-cell {
            width: var(--cell-width);
            min-width: var(--cell-width);
            height: 100%;
            border-right: 1px solid var(--grid-line);
            border-bottom: 1px solid var(--grid-line);
            cursor: crosshair;
            flex-shrink: 0;
        }

        .grid-cell.bar-start { border-right: 2px solid var(--grid-line-bar); }

        /* Notes */
        .note {
            position: absolute;
            height: calc(var(--cell-height) - 2px);
            border-radius: 4px;
            cursor: pointer;
            z-index: 10;
            display: flex;
            align-items: center;
            padding-left: 4px;
            font-size: 8px;
            font-weight: 700;
            color: rgba(0,0,0,0.7);
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.2);
            transition: transform 0.1s, box-shadow 0.1s;
        }

        .note:hover {
            transform: scale(1.02);
            box-shadow: 0 4px 8px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.3);
        }

        .note.selected { 
            box-shadow: 0 0 0 2px #fff, 0 4px 12px rgba(0,0,0,0.5); 
            transform: scale(1.02);
        }
        .note.preview { opacity: 0.5; pointer-events: none; }

        .selection-box {
            position: absolute;
            border: 2px dashed var(--accent-cyan);
            background: rgba(0, 212, 255, 0.1);
            pointer-events: none;
            z-index: 50;
            border-radius: 4px;
        }

        .note-resize {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 12px;
            cursor: ew-resize;
            background: linear-gradient(90deg, transparent, rgba(0,0,0,0.3));
            border-radius: 0 4px 4px 0;
        }

        /* Playhead */
        .playhead {
            position: absolute;
            top: 0;
            width: 3px;
            height: 100%;
            background: linear-gradient(180deg, #ff3333, #ff6666);
            box-shadow: 0 0 15px #ff3333, 0 0 30px rgba(255,51,51,0.5);
            z-index: 100;
            pointer-events: none;
        }

        /* Tracks Section */
        .audio-tracks-section {
            display: flex;
            flex-direction: column;
            border-top: 2px solid var(--border-color);
            max-height: 30%;
            min-height: 80px;
            overflow: hidden;
        }

        .tracks-header {
            display: flex;
            align-items: center;
            padding: 4px 8px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            gap: 8px;
            flex-shrink: 0;
        }

        .tracks-header h3 {
            font-size: 10px;
            color: var(--accent-cyan);
            font-weight: 600;
            letter-spacing: 1px;
        }

        .tracks-container {
            flex: 1;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        .audio-track {
            display: flex;
            border-bottom: 1px solid var(--border-color);
            border-left: 3px solid transparent;
            height: 60px;
            min-height: 60px;
            transition: background 0.2s, border-color 0.2s;
            overflow: hidden;
        }

        .audio-track.active { 
            background: linear-gradient(90deg, rgba(0,255,136,0.1) 0%, transparent 50%);
            border-left-color: var(--accent-green);
        }

        .track-info {
            width: 95px;
            min-width: 95px;
            padding: 4px 5px;
            background: linear-gradient(145deg, var(--bg-secondary), var(--bg-primary));
            border-right: 1px solid var(--border-color);
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            gap: 1px;
            overflow: hidden;
        }

        .track-name-row {
            display: flex;
            align-items: center;
            gap: 3px;
            overflow: hidden;
        }

        .track-name-input {
            background: transparent;
            border: none;
            font-family: 'JetBrains Mono', monospace;
            font-size: 9px;
            font-weight: 700;
            flex: 1;
            min-width: 0;
            width: 50px;
            color: var(--text-primary);
            padding: 0;
        }

        .track-sub-label {
            font-size: 7px;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .track-instrument-select {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 7px;
            color: var(--accent-cyan);
            padding: 1px 2px;
            width: 100%;
        }

        .track-controls {
            display: flex;
            gap: 2px;
        }

        .track-btn {
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(145deg, var(--bg-tertiary), var(--bg-primary));
            border: 1px solid var(--border-color);
            border-radius: 3px;
            color: var(--text-secondary);
            font-size: 7px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
        }

        .track-btn:active {
            transform: scale(0.9);
        }

        .track-btn.active {
            background: linear-gradient(145deg, var(--accent-green), #00cc6a);
            color: #000;
            border: none;
            box-shadow: 0 0 8px rgba(0,255,136,0.4);
        }

        .track-btn.mute.active {
            background: var(--accent-orange);
        }

        .track-btn.delete {
            background: var(--accent-pink);
            color: #000;
        }

        .track-notes-preview {
            flex: 1;
            position: relative;
            background: var(--bg-grid);
            overflow: hidden;
        }

        .track-preview-inner {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
        }

        .track-bar-line {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 1px;
            background: var(--grid-line-bar);
        }

        .track-note-bar {
            position: absolute;
            height: 3px;
            border-radius: 1px;
        }

        .track-playhead {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: #ff3333;
            z-index: 50;
        }

        /* Logo */
        .logo {
            font-size: 12px;
            font-weight: 700;
            background: linear-gradient(135deg, var(--accent-green), var(--accent-cyan));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 4px; height: 4px; }
        ::-webkit-scrollbar-track { background: var(--bg-secondary); }
        ::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 2px; }

        /* Landscape optimization */
        @media (max-height: 500px) {
            .toolbar { padding: 4px 6px; min-height: 40px; }
            .toolbar-btn { padding: 6px 10px; font-size: 10px; }
            .audio-tracks-section { max-height: 25%; min-height: 60px; }
            .audio-track { height: 50px; min-height: 50px; }
        }

        /* Phone portrait */
        @media (max-width: 600px) and (orientation: portrait) {
            :root {
                --cell-width: 20px;
                --cell-height: 16px;
                --piano-width: 36px;
            }
            .toolbar { gap: 4px; }
            .toolbar-btn { padding: 6px 8px; font-size: 10px; }
            .track-info { width: 80px; }
        }

        /* Desktop Mode Styles */
        body.desktop-mode .main-content {
            flex-direction: row;
        }
        body.desktop-mode .tracks-panel {
            width: 280px;
            min-width: 280px;
            max-width: 280px;
            flex-direction: column;
            border-right: 1px solid var(--border-color);
            border-top: none;
        }
        body.desktop-mode .editor-panel {
            flex: 1;
        }
        body.desktop-mode .audio-track {
            height: 70px;
            min-height: 70px;
        }
        body.desktop-mode .track-info {
            width: 100px;
        }
        body.desktop-mode .track-notes-preview {
            height: 50px;
        }
        body.desktop-mode :root {
            --cell-width: 32px;
            --cell-height: 22px;
        }
    </style>
</head>
<body>
    <!-- Start Screen -->
    <div class="start-screen" id="startScreen">
        <div class="start-icon">🎹</div>
        <div class="start-logo">TabletDAW</div>
        <div class="start-subtitle">Mobile Music Studio</div>
        <div class="start-version">v1.0</div>
        <button class="new-project-btn" onclick="createNewProject()">
            <span>🚀</span> 시작하기
        </button>
        <div class="install-hint" id="installHint"></div>
    </div>

    <!-- App Container -->
    <div class="app-container" id="appContainer">
        <div class="modal-overlay" id="modalOverlay">
            <div class="modal">
                <div class="modal-title">새 프로젝트</div>
                <div class="modal-message">현재 프로젝트의 모든 내용이 삭제됩니다. 계속하시겠습니까?</div>
                <div class="modal-buttons">
                    <button class="modal-btn cancel" onclick="closeModal()">취소</button>
                    <button class="modal-btn confirm" onclick="confirmNewProject()">확인</button>
                </div>
            </div>
        </div>

        <!-- Track Type Selection Modal -->
        <div class="modal-overlay" id="trackTypeModal">
            <div class="modal">
                <div class="modal-title">트랙 추가</div>
                <div class="modal-message">추가할 트랙 종류를 선택하세요</div>
                <div class="track-type-buttons">
                    <button class="track-type-btn note-type" onclick="addTrackByType('note')">
                        <span class="track-type-icon">🎹</span>
                        <span class="track-type-name">노트 트랙</span>
                        <span class="track-type-desc">피아노 롤로 음악 작성</span>
                    </button>
                    <button class="track-type-btn drum-type" onclick="addTrackByType('drum')">
                        <span class="track-type-icon">🥁</span>
                        <span class="track-type-name">드럼 트랙</span>
                        <span class="track-type-desc">비트 시퀀서</span>
                    </button>
                    <button class="track-type-btn record-type" onclick="addTrackByType('record')">
                        <span class="track-type-icon">🎙️</span>
                        <span class="track-type-name">레코드 트랙</span>
                        <span class="track-type-desc">마이크로 녹음</span>
                    </button>
                    <button class="track-type-btn audio-type" onclick="importAudioTrack()">
                        <span class="track-type-icon">📁</span>
                        <span class="track-type-name">오디오 불러오기</span>
                        <span class="track-type-desc">파일에서 가져오기</span>
                    </button>
                </div>
                <div class="modal-buttons" style="margin-top: 16px;">
                    <button class="modal-btn cancel" onclick="closeTrackTypeModal()">취소</button>
                </div>
            </div>
        </div>

        <!-- Save Modal -->
        <div class="modal-overlay" id="saveModal">
            <div class="modal">
                <div class="modal-title">💾 프로젝트 저장</div>
                <div class="modal-form">
                    <input type="text" class="modal-input" id="projectName" placeholder="프로젝트 이름" value="My Project">
                    <div class="save-options">
                        <button class="save-option-btn" onclick="saveToStorage()">
                            <span>📱</span> 로컬 저장
                        </button>
                        <button class="save-option-btn" onclick="exportProject()">
                            <span>📤</span> 파일 내보내기
                        </button>
                    </div>
                </div>
                <div class="saved-projects" id="savedProjects"></div>
                <div class="modal-buttons">
                    <button class="modal-btn cancel" onclick="closeSaveModal()">닫기</button>
                </div>
            </div>
        </div>

        <!-- Load Modal -->
        <div class="modal-overlay" id="loadModal">
            <div class="modal">
                <div class="modal-title">📂 프로젝트 불러오기</div>
                <div class="load-options">
                    <button class="load-option-btn" onclick="document.getElementById('projectFileInput').click()">
                        <span>📁</span> 파일에서 불러오기
                    </button>
                    <input type="file" id="projectFileInput" accept=".tdaw,.json" style="display:none" onchange="importProject(event)">
                </div>
                <div class="saved-projects-list" id="savedProjectsList"></div>
                <div class="modal-buttons">
                    <button class="modal-btn cancel" onclick="closeLoadModal()">닫기</button>
                </div>
            </div>
        </div>

        <!-- Settings Modal -->
        <div class="modal-overlay" id="settingsModal">
            <div class="modal settings-modal">
                <div class="modal-title">⚙️ 설정</div>
                <div class="settings-section">
                    <div class="settings-label">인터페이스 모드</div>
                    <select class="settings-select" id="interfaceModeSelect" onchange="changeInterfaceMode()">
                        <option value="tablet">태블릿 모드</option>
                        <option value="desktop">데스크탑 모드</option>
                    </select>
                </div>
                <div class="settings-section">
                    <div class="settings-label">노트 오디션 (미리듣기)</div>
                    <select class="settings-select" id="auditionSelect" onchange="changeAuditionSetting()">
                        <option value="on">켜기</option>
                        <option value="off">끄기</option>
                    </select>
                </div>
                <div class="settings-section">
                    <div class="settings-label">오디오 입력 (마이크)</div>
                    <select class="settings-select" id="audioInputSelect">
                        <option value="">기본 마이크</option>
                    </select>
                </div>
                <div class="settings-section">
                    <div class="settings-label">오디오 출력</div>
                    <select class="settings-select" id="audioOutputSelect">
                        <option value="">기본 스피커</option>
                    </select>
                </div>
                <div class="settings-section">
                    <div class="settings-label">샘플 레이트</div>
                    <select class="settings-select" id="sampleRateSelect">
                        <option value="44100">44.1 kHz</option>
                        <option value="48000" selected>48 kHz</option>
                        <option value="96000">96 kHz</option>
                    </select>
                </div>
                <div class="settings-section">
                    <div class="settings-label">버퍼 사이즈</div>
                    <select class="settings-select" id="bufferSizeSelect">
                        <option value="256">256 (낮은 지연)</option>
                        <option value="512" selected>512</option>
                        <option value="1024">1024</option>
                        <option value="2048">2048 (안정적)</option>
                    </select>
                </div>
                <div class="modal-buttons">
                    <button class="modal-btn confirm" onclick="applySettings()">적용</button>
                    <button class="modal-btn cancel" onclick="closeSettingsModal()">닫기</button>
                </div>
            </div>
        </div>

        <!-- Hidden Audio Import Input -->
        <input type="file" id="audioFileInput" accept="audio/*" style="display:none" onchange="handleAudioImport(event)">

        <div class="toolbar">
            <span class="logo">TabletDAW</span>
            <button class="toolbar-btn" onclick="showSaveModal()" title="저장">💾</button>
            <button class="toolbar-btn" onclick="showLoadModal()" title="불러오기">📂</button>
            <button class="toolbar-btn new-project" onclick="showNewProjectModal()" title="새 프로젝트">📄</button>
            <button class="toolbar-btn" onclick="showSettingsModal()" title="설정">⚙️</button>
            <div class="toolbar-divider"></div>
            <button class="toolbar-btn play" id="playBtn" onclick="togglePlay()">
                <span id="playIcon">▶</span>
            </button>
            <button class="toolbar-btn stop" onclick="stopPlayback()">⏹</button>
            <div class="bpm-control">
                <span class="bpm-label">BPM</span>
                <input type="number" class="bpm-input" id="bpmInput" value="120" min="60" max="200">
            </div>
            <button class="toolbar-btn" id="metronomeBtn" onclick="toggleMetronome()" title="메트로놈">🎚️</button>
            <div class="toolbar-divider"></div>
            <div class="track-selector">
                <select class="track-dropdown" id="trackSelect" onchange="switchTrack()">
                    <option value="0">Track 1</option>
                </select>
                <button class="toolbar-btn" onclick="addNewTrack()" title="트랙 추가">+</button>
                <button class="toolbar-btn" onclick="deleteCurrentTrack()" title="트랙 삭제">-</button>
            </div>
            <!-- 숨겨진 상태로 유지 (코드 호환성) -->
            <div class="instrument-selector" style="display:none;">
                <select class="instrument-dropdown" id="instrumentSelect" onchange="changeCurrentInstrument()">
                </select>
            </div>
            <div style="display:none;">
                <select id="gridSelect">
                    <option value="1">1/4</option>
                    <option value="2">1/8</option>
                    <option value="4" selected>1/16</option>
                    <option value="8">1/32</option>
                </select>
            </div>
            <div class="time-display" id="timeDisplay">00:00</div>
        </div>

        <div class="main-content">
            <div class="piano-roll-section">
                <!-- 피아노 롤 헤더 -->
                <div class="piano-roll-header" id="pianoRollHeader">
                    <span class="piano-roll-label">🎹</span>
                    <select class="instrument-dropdown-mini" id="instrumentSelectMini" onchange="changeCurrentInstrument()">
                    </select>
                    <div class="note-tools">
                        <button class="note-tool-btn active" id="notePencilTool" onclick="setNoteTool('pencil')" title="연필">✏️</button>
                        <button class="note-tool-btn" id="noteSelectTool" onclick="setNoteTool('select')" title="선택">👆</button>
                        <button class="note-tool-btn" id="noteEraserTool" onclick="setNoteTool('eraser')" title="지우개">🧹</button>
                    </div>
                    <div class="note-tools">
                        <button class="note-tool-btn" onclick="selectAllNotes()" title="전체 선택">☑️</button>
                        <button class="note-tool-btn" onclick="copySelectedNotes()" title="복사">📋</button>
                        <button class="note-tool-btn" onclick="pasteNotes()" title="붙여넣기">📄</button>
                        <button class="note-tool-btn" onclick="deleteSelectedNotes()" title="삭제">🗑️</button>
                    </div>
                    <select class="grid-select-mini" id="gridSelectMini" onchange="changeGridResolution()">
                        <option value="1">1/4</option>
                        <option value="2">1/8</option>
                        <option value="4" selected>1/16</option>
                        <option value="8">1/32</option>
                    </select>
                </div>
                <div class="timeline-wrapper" id="noteTimelineWrapper">
                    <div class="timeline-spacer"></div>
                    <div class="timeline" id="timeline">
                        <div class="timeline-inner" id="timelineInner"></div>
                    </div>
                </div>
                <div class="piano-roll-container" id="pianoRollContainer">
                    <div class="piano-keys" id="pianoKeys"></div>
                    <div class="piano-grid-wrapper" id="pianoGridWrapper">
                        <div class="piano-grid" id="pianoGrid">
                            <div class="playhead" id="playhead"></div>
                        </div>
                    </div>
                    <!-- Empty State -->
                    <div class="empty-state" id="emptyState">
                        <div class="empty-state-icon">🎵</div>
                        <div class="empty-state-title">트랙이 없습니다</div>
                        <div class="empty-state-text">아래 + Add 버튼을 눌러<br>트랙을 추가하세요</div>
                        <button class="empty-state-btn" onclick="addNewTrack()">+ 트랙 추가</button>
                    </div>
                </div>

                <!-- Record Track View -->
                <div class="record-track-view" id="recordTrackView">
                    <div class="record-controls">
                        <button class="record-btn rec" id="recBtn" onclick="toggleRecording()">⏺</button>
                        <button class="record-btn stop-rec" onclick="stopRecording()">⏹</button>
                        <div class="record-divider"></div>
                        <button class="record-btn edit-tool" id="selectTool" onclick="setEditTool('select')" title="선택/이동">✋</button>
                        <button class="record-btn edit-tool" id="trimTool" onclick="setEditTool('trim')" title="트림">↔️</button>
                        <button class="record-btn edit-tool" id="splitTool" onclick="setEditTool('split')" title="분할">✂️</button>
                        <button class="record-btn edit-tool" id="deleteTool" onclick="deleteSelectedClip()" title="삭제">🗑️</button>
                        <div class="record-divider"></div>
                        <button class="record-btn stop-rec" onclick="document.getElementById('sampleFileInput').click()" title="샘플 추가">📁</button>
                        <input type="file" id="sampleFileInput" accept="audio/*" style="display:none" onchange="addSampleToTrack(event)">
                        <span class="record-status" id="recordStatus">녹음 대기</span>
                    </div>
                    <div class="record-timeline-wrapper">
                        <div class="record-timeline" id="recordTimeline"></div>
                    </div>
                    <div class="waveform-container" id="waveformContainer">
                        <div class="waveform-area" id="waveformArea">
                            <div class="waveform-grid" id="waveformGrid"></div>
                            <div class="clips-container" id="clipsContainer"></div>
                            <div class="waveform-placeholder" id="waveformPlaceholder">
                                <div class="waveform-placeholder-icon">🎙️</div>
                                <div class="waveform-placeholder-text">녹음 버튼을 눌러 시작하세요<br><small>또는 📁 버튼으로 오디오 파일 추가</small></div>
                            </div>
                            <div class="record-playhead" id="recordPlayhead" style="left: 0;"></div>
                            <div class="split-cursor" id="splitCursor"></div>
                        </div>
                    </div>
                </div>

                <!-- Drum Track View -->
                <div class="drum-track-view" id="drumTrackView">
                    <div class="drum-kit-header">
                        <span class="drum-kit-label">🥁</span>
                        <select class="drum-kit-select" id="drumKitSelect" onchange="changeDrumKit()">
                            <option value="acoustic">Acoustic</option>
                            <option value="electronic">Electronic</option>
                            <option value="hiphop">Hip-Hop</option>
                            <option value="808">808</option>
                        </select>
                        <div class="drum-tools">
                            <button class="drum-tool-btn active" id="drumPencilTool" onclick="setDrumTool('pencil')" title="연필">✏️</button>
                            <button class="drum-tool-btn" id="drumSelectTool" onclick="setDrumTool('select')" title="선택">👆</button>
                            <button class="drum-tool-btn" id="drumEraserTool" onclick="setDrumTool('eraser')" title="지우개">🧹</button>
                        </div>
                        <button class="drum-header-btn" onclick="clearDrumPattern()" title="패턴 지우기">🗑️</button>
                    </div>
                    <div class="drum-timeline-wrapper">
                        <div class="drum-timeline-spacer"></div>
                        <div class="drum-timeline" id="drumTimeline"></div>
                    </div>
                    <div class="drum-grid-container">
                        <div class="drum-labels" id="drumLabels"></div>
                        <div class="drum-grid-wrapper" id="drumGridWrapper">
                            <div class="drum-grid" id="drumGrid"></div>
                            <div class="drum-playhead" id="drumPlayhead" style="left:0;"></div>
                            <div class="drum-selection-box" id="drumSelectionBox" style="display:none;"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="audio-tracks-section">
                <div class="tracks-header">
                    <h3>TRACKS</h3>
                    <button class="toolbar-btn" onclick="addAudioTrack()" style="padding:4px 8px;font-size:9px;">+ Add</button>
                </div>
                <div class="tracks-container" id="tracksContainer"></div>
            </div>
        </div>
    </div>

    <script>
        // Register Service Worker
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js')
                .then(reg => console.log('SW registered'))
                .catch(err => console.log('SW registration failed:', err));
        }

        // Install prompt
        let deferredPrompt;
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            document.getElementById('installHint').innerHTML = 
                '💡 홈 화면에 추가하려면 브라우저 메뉴에서 "홈 화면에 추가"를 선택하세요';
        });

        // Instruments configuration
        const INSTRUMENTS = {
            piano: {
                name: '🎹 Piano',
                type: 'triangle',
                attack: 0.005,
                decay: 0.4,
                sustain: 0.3,
                release: 0.4,
                harmonics: [1, 0.6, 0.3, 0.15, 0.08],
                filterType: 'lowpass',
                filterFreq: 4000
            },
            epiano: {
                name: '🎹 E.Piano',
                type: 'sine',
                attack: 0.002,
                decay: 0.5,
                sustain: 0.25,
                release: 0.4,
                harmonics: [1, 0.5, 0.25, 0.12, 0.06],
                detuneAmount: 3,
                filterType: 'lowpass',
                filterFreq: 3500
            },
            synth: {
                name: '🎛️ Synth',
                type: 'sawtooth',
                attack: 0.05,
                decay: 0.2,
                sustain: 0.6,
                release: 0.2,
                harmonics: [1, 0.5],
                filterType: 'lowpass',
                filterFreq: 2500
            },
            lead: {
                name: '🎛️ Lead',
                type: 'square',
                attack: 0.02,
                decay: 0.1,
                sustain: 0.8,
                release: 0.15,
                harmonics: [1, 0.3],
                filterType: 'lowpass',
                filterFreq: 3000
            },
            bass: {
                name: '🎸 Bass',
                type: 'sawtooth',
                attack: 0.01,
                decay: 0.15,
                sustain: 0.6,
                release: 0.1,
                harmonics: [1, 0.7, 0.3],
                octaveShift: -1,
                filterType: 'lowpass',
                filterFreq: 800
            },
            synthbass: {
                name: '🔊 Synth Bass',
                type: 'sawtooth',
                attack: 0.005,
                decay: 0.2,
                sustain: 0.5,
                release: 0.1,
                harmonics: [1, 0.9, 0.4],
                octaveShift: -1,
                filterType: 'lowpass',
                filterFreq: 600
            },
            guitar: {
                name: '🎸 Guitar',
                type: 'custom',
                attack: 0.002,
                decay: 0.8,
                sustain: 0.15,
                release: 0.3,
                harmonics: [1, 0.9, 0.7, 0.5, 0.35, 0.2, 0.1],
                filterType: 'lowpass',
                filterFreq: 2800,
                pluck: true
            },
            acousticguitar: {
                name: '🎸 Acoustic',
                type: 'custom',
                attack: 0.001,
                decay: 1.0,
                sustain: 0.1,
                release: 0.4,
                harmonics: [1, 0.85, 0.65, 0.45, 0.3, 0.2, 0.12, 0.08],
                filterType: 'lowpass',
                filterFreq: 3200,
                pluck: true,
                bodyResonance: true
            },
            electricguitar: {
                name: '🎸 E.Guitar',
                type: 'custom',
                attack: 0.002,
                decay: 0.6,
                sustain: 0.4,
                release: 0.25,
                harmonics: [1, 0.95, 0.8, 0.6, 0.4, 0.25],
                filterType: 'lowpass',
                filterFreq: 3500,
                pluck: true,
                distortion: 0.1
            },
            nylonguitar: {
                name: '🎸 Nylon',
                type: 'custom',
                attack: 0.001,
                decay: 1.2,
                sustain: 0.08,
                release: 0.5,
                harmonics: [1, 0.7, 0.5, 0.35, 0.2, 0.1],
                filterType: 'lowpass',
                filterFreq: 2500,
                pluck: true,
                bodyResonance: true
            },
            organ: {
                name: '🎵 Organ',
                type: 'sine',
                attack: 0.02,
                decay: 0.05,
                sustain: 0.95,
                release: 0.08,
                harmonics: [1, 1, 0.5, 0.5, 0.25]
            },
            strings: {
                name: '🎻 Strings',
                type: 'sawtooth',
                attack: 0.25,
                decay: 0.2,
                sustain: 0.8,
                release: 0.5,
                harmonics: [1, 0.6, 0.4, 0.2],
                detuneAmount: 4,
                filterType: 'lowpass',
                filterFreq: 4000
            },
            violin: {
                name: '🎻 Violin',
                type: 'sawtooth',
                attack: 0.12,
                decay: 0.1,
                sustain: 0.85,
                release: 0.25,
                harmonics: [1, 0.7, 0.4, 0.2, 0.1],
                filterType: 'lowpass',
                filterFreq: 5000
            },
            cello: {
                name: '🎻 Cello',
                type: 'sawtooth',
                attack: 0.15,
                decay: 0.15,
                sustain: 0.8,
                release: 0.3,
                harmonics: [1, 0.75, 0.5, 0.3, 0.15],
                octaveShift: -1,
                filterType: 'lowpass',
                filterFreq: 2500
            },
            pad: {
                name: '☁️ Pad',
                type: 'sine',
                attack: 0.5,
                decay: 0.3,
                sustain: 0.7,
                release: 0.6,
                harmonics: [1, 0.4, 0.2],
                detuneAmount: 5
            },
            choir: {
                name: '🎤 Choir',
                type: 'sine',
                attack: 0.35,
                decay: 0.2,
                sustain: 0.75,
                release: 0.5,
                harmonics: [1, 0.8, 0.5, 0.3, 0.15],
                detuneAmount: 4,
                filterType: 'lowpass',
                filterFreq: 3000
            },
            pluck: {
                name: '🪕 Pluck',
                type: 'triangle',
                attack: 0.002,
                decay: 0.25,
                sustain: 0.05,
                release: 0.15,
                harmonics: [1, 0.8, 0.5, 0.3],
                filterType: 'lowpass',
                filterFreq: 2000,
                pluck: true
            },
            marimba: {
                name: '🎵 Marimba',
                type: 'sine',
                attack: 0.002,
                decay: 0.5,
                sustain: 0.05,
                release: 0.4,
                harmonics: [1, 0.4, 0.15, 0.05]
            },
            vibraphone: {
                name: '🎵 Vibes',
                type: 'sine',
                attack: 0.002,
                decay: 0.8,
                sustain: 0.3,
                release: 0.6,
                harmonics: [1, 0.3, 0.1],
                detuneAmount: 1
            },
            square: {
                name: '🔲 Square',
                type: 'square',
                attack: 0.02,
                decay: 0.1,
                sustain: 0.5,
                release: 0.1,
                harmonics: [1],
                filterType: 'lowpass',
                filterFreq: 2000
            },
            bell: {
                name: '🔔 Bell',
                type: 'sine',
                attack: 0.002,
                decay: 0.6,
                sustain: 0.15,
                release: 0.5,
                harmonics: [1, 0.65, 0.45, 0.3, 0.2],
                detuneAmount: 8
            },
            brass: {
                name: '🎺 Brass',
                type: 'sawtooth',
                attack: 0.06,
                decay: 0.15,
                sustain: 0.7,
                release: 0.12,
                harmonics: [1, 0.85, 0.65, 0.45, 0.25],
                filterType: 'lowpass',
                filterFreq: 2500
            },
            trumpet: {
                name: '🎺 Trumpet',
                type: 'sawtooth',
                attack: 0.04,
                decay: 0.1,
                sustain: 0.75,
                release: 0.1,
                harmonics: [1, 0.9, 0.7, 0.5, 0.3],
                filterType: 'lowpass',
                filterFreq: 3500
            },
            flute: {
                name: '🎵 Flute',
                type: 'sine',
                attack: 0.08,
                decay: 0.08,
                sustain: 0.85,
                release: 0.12,
                harmonics: [1, 0.25, 0.08],
                filterType: 'highpass',
                filterFreq: 400
            },
            clarinet: {
                name: '🎵 Clarinet',
                type: 'square',
                attack: 0.06,
                decay: 0.1,
                sustain: 0.8,
                release: 0.12,
                harmonics: [1, 0.75, 0.5, 0.25],
                filterType: 'lowpass',
                filterFreq: 2000
            }
        };

        // Drum Kit Definitions
        const DRUM_KITS = {
            acoustic: {
                name: 'Acoustic Kit',
                sounds: [
                    { name: 'Kick', freq: 60, type: 'kick' },
                    { name: 'Snare', freq: 200, type: 'snare' },
                    { name: 'Hi-Hat C', freq: 8000, type: 'hihat-closed' },
                    { name: 'Hi-Hat O', freq: 8000, type: 'hihat-open' },
                    { name: 'Tom H', freq: 200, type: 'tom' },
                    { name: 'Tom M', freq: 150, type: 'tom' },
                    { name: 'Tom L', freq: 100, type: 'tom' },
                    { name: 'Crash', freq: 5000, type: 'crash' }
                ]
            },
            electronic: {
                name: 'Electronic Kit',
                sounds: [
                    { name: 'Kick', freq: 50, type: 'kick' },
                    { name: 'Snare', freq: 250, type: 'snare' },
                    { name: 'Hi-Hat', freq: 10000, type: 'hihat-closed' },
                    { name: 'Clap', freq: 1500, type: 'clap' },
                    { name: 'Rim', freq: 800, type: 'rim' },
                    { name: 'Perc 1', freq: 400, type: 'perc' },
                    { name: 'Perc 2', freq: 600, type: 'perc' },
                    { name: 'Cymbal', freq: 6000, type: 'crash' }
                ]
            },
            hiphop: {
                name: 'Hip-Hop Kit',
                sounds: [
                    { name: 'Kick', freq: 45, type: 'kick' },
                    { name: 'Snare', freq: 180, type: 'snare' },
                    { name: 'Hat', freq: 9000, type: 'hihat-closed' },
                    { name: 'Open Hat', freq: 7000, type: 'hihat-open' },
                    { name: 'Clap', freq: 1200, type: 'clap' },
                    { name: 'Snap', freq: 2000, type: 'rim' },
                    { name: 'Perc', freq: 500, type: 'perc' },
                    { name: 'FX', freq: 300, type: 'fx' }
                ]
            },
            '808': {
                name: '808 Kit',
                sounds: [
                    { name: '808 Kick', freq: 40, type: '808kick' },
                    { name: '808 Snare', freq: 160, type: 'snare' },
                    { name: 'Hat', freq: 8500, type: 'hihat-closed' },
                    { name: 'Open Hat', freq: 6000, type: 'hihat-open' },
                    { name: 'Clap', freq: 1000, type: 'clap' },
                    { name: 'Cowbell', freq: 800, type: 'rim' },
                    { name: 'Tom', freq: 120, type: 'tom' },
                    { name: 'Cymbal', freq: 4000, type: 'crash' }
                ]
            }
        };

        let currentDrumKit = 'acoustic';

        // IndexedDB for project storage
        const DB_NAME = 'TabletDAW';
        const DB_VERSION = 1;
        let db = null;

        async function initDatabase() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                
                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    db = request.result;
                    resolve(db);
                };
                
                request.onupgradeneeded = (event) => {
                    const database = event.target.result;
                    if (!database.objectStoreNames.contains('projects')) {
                        database.createObjectStore('projects', { keyPath: 'id' });
                    }
                };
            });
        }

        // Config - Base unit is 1/32 note
        const BASE_CELL_WIDTH = 12; // 1/32 노트의 기본 너비
        const CELL_HEIGHT = 18;
        let totalBars = 16; // 마디 수 (동적)
        const BEATS_PER_BAR = 4;
        const SUBS_PER_BEAT = 8; // 1비트 = 8개의 1/32 노트
        
        // Grid resolution: 1=1/4, 2=1/8, 4=1/16, 8=1/32
        let gridResolution = 4; // 기본값 1/16
        
        // 동적 계산 함수들
        function getTotalBeats() { return totalBars * BEATS_PER_BAR; }
        function getSubCellWidth() { return BASE_CELL_WIDTH; }
        function getBeatWidth() { return BASE_CELL_WIDTH * SUBS_PER_BEAT; } // 1비트 너비
        function getBarWidth() { return getBeatWidth() * BEATS_PER_BAR; } // 1마디 너비
        function getGridTotalWidth() { return getBarWidth() * totalBars; } // 전체 너비
        function getSnapUnit() { return 1 / gridResolution; } // 스냅 단위 (비트)
        function getSnapPixels() { return getBeatWidth() / gridResolution; } // 스냅 픽셀
        
        const TRACK_COLORS = ['#00ff88','#ff3399','#00d4ff','#ffcc00','#9966ff','#ff6633','#33ff99','#ff66cc'];

        let audioContext = null, isPlaying = false, bpm = 120, playheadPosition = 0;
        let animationFrame = null, startTime = 0, currentTrackIndex = -1, auditionEnabled = true;
        let isDrawing = false, drawStartBeat = 0, drawStartRow = 0, drawStartNote = '', previewNote = null;
        let tracks = [];
        const activeOscillators = new Map();
        const keyNames = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
        const octaves = [6,5,4,3,2,1];
        const blackKeyIndices = [1,3,6,8,10];
        const totalRows = octaves.length * 12;

        // Initialize instrument dropdown
        function initInstrumentDropdown() {
            const select = document.getElementById('instrumentSelect');
            const selectMini = document.getElementById('instrumentSelectMini');
            select.innerHTML = '';
            selectMini.innerHTML = '';
            Object.keys(INSTRUMENTS).forEach(key => {
                const opt = document.createElement('option');
                opt.value = key;
                opt.textContent = INSTRUMENTS[key].name;
                select.appendChild(opt);
                
                const optMini = document.createElement('option');
                optMini.value = key;
                optMini.textContent = INSTRUMENTS[key].name;
                selectMini.appendChild(optMini);
            });
        }

        // Change current track instrument
        function changeCurrentInstrument() {
            const instrumentMini = document.getElementById('instrumentSelectMini');
            const instrument = instrumentMini.value;
            if (!tracks[currentTrackIndex]) return;
            tracks[currentTrackIndex].instrument = instrument;
            const trackEl = document.querySelector(`.audio-track[data-track-id="${currentTrackIndex}"] .track-instrument-select`);
            if (trackEl) trackEl.value = instrument;
        }

        // Change track instrument from track panel
        function changeTrackInstrument(trackId, instrument) {
            tracks[trackId].instrument = instrument;
            if (trackId === currentTrackIndex) {
                document.getElementById('instrumentSelectMini').value = instrument;
            }
        }

        // Modal
        function showNewProjectModal() { document.getElementById('modalOverlay').classList.add('show'); }
        function closeModal() { document.getElementById('modalOverlay').classList.remove('show'); }
        function confirmNewProject() { closeModal(); resetProject(); }

        // Track Type Modal
        function showTrackTypeModal() { document.getElementById('trackTypeModal').classList.add('show'); }
        function closeTrackTypeModal() { document.getElementById('trackTypeModal').classList.remove('show'); }

        function addTrackByType(type) {
            closeTrackTypeModal();
            const i = tracks.length;
            
            let trackName = 'Track ' + (i + 1);
            if (type === 'note') trackName = 'Note ' + (i + 1);
            else if (type === 'drum') trackName = 'Drum ' + (i + 1);
            else if (type === 'record') trackName = 'Audio ' + (i + 1);
            
            const track = { 
                name: trackName, 
                type: type,
                notes: [], 
                clips: [],
                pattern: type === 'drum' ? createEmptyDrumPattern() : null,
                drumKit: 'acoustic',
                color: TRACK_COLORS[i % TRACK_COLORS.length], 
                muted: false, 
                solo: false, 
                instrument: 'piano' 
            };
            
            tracks.push(track);
            const sel = document.getElementById('trackSelect');
            const opt = document.createElement('option');
            opt.value = i; 
            opt.textContent = tracks[i].name;
            sel.appendChild(opt);
            sel.value = i;
            currentTrackIndex = i;
            renderNotes();
            addAudioTrackUI(i);
            updateTrackSelection();
            updateTrackView();
            updateEmptyState();
            
            if (type === 'drum') {
                initDrumGrid();
            }
        }

        // Save Modal Functions
        function showSaveModal() {
            document.getElementById('saveModal').classList.add('show');
            loadSavedProjectsList('savedProjects');
        }
        function closeSaveModal() { document.getElementById('saveModal').classList.remove('show'); }

        // Load Modal Functions
        function showLoadModal() {
            document.getElementById('loadModal').classList.add('show');
            loadSavedProjectsList('savedProjectsList');
        }
        function closeLoadModal() { document.getElementById('loadModal').classList.remove('show'); }

        // Settings Modal Functions
        let interfaceMode = 'tablet'; // 'tablet' or 'desktop'
        
        function showSettingsModal() {
            document.getElementById('settingsModal').classList.add('show');
            document.getElementById('auditionSelect').value = auditionEnabled ? 'on' : 'off';
            document.getElementById('interfaceModeSelect').value = interfaceMode;
            enumerateAudioDevices();
        }
        function closeSettingsModal() { document.getElementById('settingsModal').classList.remove('show'); }
        
        function changeAuditionSetting() {
            auditionEnabled = document.getElementById('auditionSelect').value === 'on';
        }
        
        function changeInterfaceMode() {
            interfaceMode = document.getElementById('interfaceModeSelect').value;
            if (interfaceMode === 'desktop') {
                document.body.classList.add('desktop-mode');
            } else {
                document.body.classList.remove('desktop-mode');
            }
            // 그리드 크기 재계산
            setTimeout(() => {
                initPianoRoll();
                initTimeline();
                renderNotes();
                updateTrackPreviews();
            }, 100);
        }

        // Audio Device Enumeration
        async function enumerateAudioDevices() {
            try {
                // Request permission first
                await navigator.mediaDevices.getUserMedia({ audio: true });
                
                const devices = await navigator.mediaDevices.enumerateDevices();
                const inputSelect = document.getElementById('audioInputSelect');
                const outputSelect = document.getElementById('audioOutputSelect');
                
                inputSelect.innerHTML = '<option value="">기본 마이크</option>';
                outputSelect.innerHTML = '<option value="">기본 스피커</option>';
                
                devices.forEach(device => {
                    const opt = document.createElement('option');
                    opt.value = device.deviceId;
                    opt.textContent = device.label || `${device.kind} (${device.deviceId.slice(0, 8)}...)`;
                    
                    if (device.kind === 'audioinput') {
                        inputSelect.appendChild(opt);
                    } else if (device.kind === 'audiooutput') {
                        outputSelect.appendChild(opt);
                    }
                });
            } catch (e) {
                console.log('Cannot enumerate devices:', e);
            }
        }

        function applySettings() {
            const sampleRate = parseInt(document.getElementById('sampleRateSelect').value);
            // Note: Changing sample rate requires recreating AudioContext
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }
            closeSettingsModal();
            showToast('설정이 적용되었습니다');
        }

        // Save/Load Project Functions
        async function saveToStorage() {
            const projectName = document.getElementById('projectName').value || 'Untitled';
            
            try {
                if (!db) await initDatabase();
                
                // Serialize tracks (convert AudioBuffers to array buffers)
                const serializedTracks = await Promise.all(tracks.map(async (track, idx) => {
                    const serialized = { ...track };
                    
                    // Handle audio clips
                    if (track.clips && track.clips.length > 0) {
                        serialized.clips = await Promise.all(track.clips.map(async clip => {
                            const clipData = { ...clip };
                            if (clip.audioBuffer) {
                                clipData.audioData = {
                                    sampleRate: clip.audioBuffer.sampleRate,
                                    channels: []
                                };
                                for (let ch = 0; ch < clip.audioBuffer.numberOfChannels; ch++) {
                                    clipData.audioData.channels.push(Array.from(clip.audioBuffer.getChannelData(ch)));
                                }
                                delete clipData.audioBuffer;
                            }
                            return clipData;
                        }));
                    }
                    
                    return serialized;
                }));
                
                const project = {
                    id: Date.now().toString(),
                    name: projectName,
                    date: new Date().toISOString(),
                    bpm: bpm,
                    totalBars: totalBars,
                    gridResolution: gridResolution,
                    tracks: serializedTracks
                };
                
                const transaction = db.transaction(['projects'], 'readwrite');
                const store = transaction.objectStore('projects');
                await store.put(project);
                
                alert('프로젝트가 저장되었습니다!');
                loadSavedProjectsList('savedProjects');
                
            } catch (e) {
                console.error('Save error:', e);
                alert('저장 중 오류가 발생했습니다.');
            }
        }

        async function loadSavedProjectsList(containerId) {
            const container = document.getElementById(containerId);
            if (!container) return;
            
            container.innerHTML = '';
            
            try {
                if (!db) await initDatabase();
                
                const transaction = db.transaction(['projects'], 'readonly');
                const store = transaction.objectStore('projects');
                const request = store.getAll();
                
                request.onsuccess = () => {
                    const projects = request.result.sort((a, b) => new Date(b.date) - new Date(a.date));
                    
                    if (projects.length === 0) {
                        container.innerHTML = '<div style="color:var(--text-secondary);text-align:center;padding:20px;">저장된 프로젝트가 없습니다</div>';
                        return;
                    }
                    
                    projects.forEach(project => {
                        const item = document.createElement('div');
                        item.className = 'saved-project-item';
                        item.innerHTML = `
                            <div>
                                <div class="saved-project-name">${project.name}</div>
                                <div class="saved-project-date">${new Date(project.date).toLocaleString()}</div>
                            </div>
                            <div>
                                <button class="saved-project-delete" onclick="event.stopPropagation(); deleteProject('${project.id}', '${containerId}')">삭제</button>
                            </div>
                        `;
                        item.addEventListener('click', () => loadProjectFromStorage(project.id));
                        container.appendChild(item);
                    });
                };
            } catch (e) {
                console.error('Load list error:', e);
            }
        }

        async function loadProjectFromStorage(projectId) {
            try {
                if (!db) await initDatabase();
                
                const transaction = db.transaction(['projects'], 'readonly');
                const store = transaction.objectStore('projects');
                const request = store.get(projectId);
                
                request.onsuccess = async () => {
                    const project = request.result;
                    if (!project) return;
                    
                    // Reset current project
                    stopPlayback();
                    
                    bpm = project.bpm || 120;
                    totalBars = project.totalBars || 16;
                    gridResolution = project.gridResolution || 4;
                    
                    document.getElementById('bpmInput').value = bpm;
                    document.getElementById('gridSelect').value = gridResolution;
                    
                    // Restore tracks
                    tracks = await Promise.all(project.tracks.map(async (trackData) => {
                        const track = { ...trackData };
                        
                        // Restore audio clips
                        if (track.clips && track.clips.length > 0) {
                            track.clips = await Promise.all(track.clips.map(async clipData => {
                                const clip = { ...clipData };
                                if (clipData.audioData) {
                                    initAudio();
                                    const audioBuffer = audioContext.createBuffer(
                                        clipData.audioData.channels.length,
                                        clipData.audioData.channels[0].length,
                                        clipData.audioData.sampleRate
                                    );
                                    clipData.audioData.channels.forEach((channelData, ch) => {
                                        audioBuffer.copyToChannel(new Float32Array(channelData), ch);
                                    });
                                    clip.audioBuffer = audioBuffer;
                                    delete clip.audioData;
                                }
                                return clip;
                            }));
                        }
                        
                        return track;
                    }));
                    
                    currentTrackIndex = tracks.length > 0 ? 0 : -1;
                    
                    initTimeline();
                    initPianoRoll();
                    rebuildTrackUI();
                    renderNotes();
                    updateTrackPreviews();
                    updateTrackSelection();
                    updateEmptyState();
                    
                    closeLoadModal();
                    closeSaveModal();
                    
                    alert(`"${project.name}" 프로젝트를 불러왔습니다!`);
                };
            } catch (e) {
                console.error('Load error:', e);
                alert('불러오기 중 오류가 발생했습니다.');
            }
        }

        async function deleteProject(projectId, containerId) {
            if (!confirm('이 프로젝트를 삭제하시겠습니까?')) return;
            
            try {
                if (!db) await initDatabase();
                
                const transaction = db.transaction(['projects'], 'readwrite');
                const store = transaction.objectStore('projects');
                await store.delete(projectId);
                
                loadSavedProjectsList(containerId);
            } catch (e) {
                console.error('Delete error:', e);
            }
        }

        // Export/Import Project as File
        async function exportProject() {
            const projectName = document.getElementById('projectName').value || 'Untitled';
            
            const serializedTracks = await Promise.all(tracks.map(async track => {
                const serialized = { ...track };
                if (track.clips && track.clips.length > 0) {
                    serialized.clips = await Promise.all(track.clips.map(async clip => {
                        const clipData = { ...clip };
                        if (clip.audioBuffer) {
                            clipData.audioData = {
                                sampleRate: clip.audioBuffer.sampleRate,
                                channels: []
                            };
                            for (let ch = 0; ch < clip.audioBuffer.numberOfChannels; ch++) {
                                clipData.audioData.channels.push(Array.from(clip.audioBuffer.getChannelData(ch)));
                            }
                            delete clipData.audioBuffer;
                        }
                        return clipData;
                    }));
                }
                return serialized;
            }));
            
            const project = {
                name: projectName,
                version: '1.0',
                date: new Date().toISOString(),
                bpm: bpm,
                totalBars: totalBars,
                gridResolution: gridResolution,
                tracks: serializedTracks
            };
            
            const json = JSON.stringify(project);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `${projectName}.tdaw`;
            a.click();
            
            URL.revokeObjectURL(url);
            closeSaveModal();
        }

        async function importProject(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            try {
                const text = await file.text();
                const project = JSON.parse(text);
                
                stopPlayback();
                
                bpm = project.bpm || 120;
                totalBars = project.totalBars || 16;
                gridResolution = project.gridResolution || 4;
                
                document.getElementById('bpmInput').value = bpm;
                document.getElementById('gridSelect').value = gridResolution;
                
                tracks = await Promise.all(project.tracks.map(async trackData => {
                    const track = { ...trackData };
                    if (track.clips && track.clips.length > 0) {
                        track.clips = await Promise.all(track.clips.map(async clipData => {
                            const clip = { ...clipData };
                            if (clipData.audioData) {
                                initAudio();
                                const audioBuffer = audioContext.createBuffer(
                                    clipData.audioData.channels.length,
                                    clipData.audioData.channels[0].length,
                                    clipData.audioData.sampleRate
                                );
                                clipData.audioData.channels.forEach((channelData, ch) => {
                                    audioBuffer.copyToChannel(new Float32Array(channelData), ch);
                                });
                                clip.audioBuffer = audioBuffer;
                                delete clip.audioData;
                            }
                            return clip;
                        }));
                    }
                    return track;
                }));
                
                currentTrackIndex = tracks.length > 0 ? 0 : -1;
                
                initTimeline();
                initPianoRoll();
                rebuildTrackUI();
                renderNotes();
                updateTrackPreviews();
                updateTrackSelection();
                updateEmptyState();
                
                closeLoadModal();
                alert(`"${project.name}" 프로젝트를 불러왔습니다!`);
                
            } catch (e) {
                console.error('Import error:', e);
                alert('파일을 불러오는 중 오류가 발생했습니다.');
            }
            
            event.target.value = '';
        }

        // Audio File Import
        function importAudioTrack() {
            closeTrackTypeModal();
            document.getElementById('audioFileInput').click();
        }

        async function handleAudioImport(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            try {
                initAudio();
                
                const arrayBuffer = await file.arrayBuffer();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                
                // Create new record track with imported audio
                const i = tracks.length;
                const track = {
                    name: file.name.replace(/\.[^/.]+$/, '').slice(0, 12),
                    type: 'record',
                    notes: [],
                    clips: [{
                        id: ++clipIdCounter,
                        audioBuffer: audioBuffer,
                        startBeat: 0,
                        trimStart: 0,
                        trimEnd: audioBuffer.duration
                    }],
                    color: TRACK_COLORS[i % TRACK_COLORS.length],
                    muted: false,
                    solo: false,
                    instrument: 'piano'
                };
                
                tracks.push(track);
                
                const sel = document.getElementById('trackSelect');
                const opt = document.createElement('option');
                opt.value = i;
                opt.textContent = track.name;
                sel.appendChild(opt);
                sel.value = i;
                currentTrackIndex = i;
                
                addAudioTrackUI(i);
                updateTrackSelection();
                updateTrackView();
                updateEmptyState();
                updateTrackPreviews();
                
                alert(`"${file.name}" 오디오 파일을 불러왔습니다!`);
                
            } catch (e) {
                console.error('Audio import error:', e);
                alert('오디오 파일을 불러오는 중 오류가 발생했습니다.');
            }
            
            event.target.value = '';
        }

        // Add sample to current track
        async function addSampleToTrack(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const track = tracks[currentTrackIndex];
            if (!track || track.type !== 'record') {
                alert('레코드 트랙에서만 샘플을 추가할 수 있습니다.');
                event.target.value = '';
                return;
            }
            
            try {
                initAudio();
                
                const arrayBuffer = await file.arrayBuffer();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                
                // 현재 플레이헤드 위치에 샘플 추가
                const beatWidth = getBeatWidth();
                const currentBeat = playheadPosition / beatWidth;
                
                const newClip = {
                    id: ++clipIdCounter,
                    audioBuffer: audioBuffer,
                    startBeat: currentBeat,
                    trimStart: 0,
                    trimEnd: audioBuffer.duration
                };
                
                if (!track.clips) track.clips = [];
                track.clips.push(newClip);
                
                document.getElementById('waveformPlaceholder').style.display = 'none';
                renderClips();
                updateWaveformGrid();
                updateTrackPreviews();
                
                const status = document.getElementById('recordStatus');
                status.textContent = `클립 ${track.clips.length}개`;
                
            } catch (e) {
                console.error('Sample import error:', e);
                alert('오디오 파일을 불러오는 중 오류가 발생했습니다.');
            }
            
            event.target.value = '';
        }

        // Drum Track Functions
        function createEmptyDrumPattern() {
            const pattern = {};
            const kit = DRUM_KITS[currentDrumKit];
            kit.sounds.forEach((sound, idx) => {
                pattern[idx] = new Array(totalBars * BEATS_PER_BAR * 4).fill(false); // 1/16 resolution
            });
            return pattern;
        }

        function renderDrumTimeline() {
            const timeline = document.getElementById('drumTimeline');
            timeline.innerHTML = '';
            
            const cellWidth = 28; // 드럼 셀 너비
            const stepsPerBeat = 4; // 1비트 = 4스텝 (1/16)
            const beatWidth = cellWidth * stepsPerBeat; // 112px
            
            let beatNum = 1;
            for (let bar = 0; bar < totalBars; bar++) {
                for (let beat = 0; beat < BEATS_PER_BAR; beat++) {
                    const beatEl = document.createElement('div');
                    beatEl.className = 'drum-timeline-beat';
                    beatEl.style.width = beatWidth + 'px';
                    beatEl.style.minWidth = beatWidth + 'px';
                    
                    // 마디의 마지막 비트 뒤에 구분선
                    if (beat === BEATS_PER_BAR - 1) {
                        beatEl.classList.add('bar-end');
                    }
                    // 마디의 첫 비트 강조
                    if (beat === 0) {
                        beatEl.classList.add('bar-first');
                    }
                    beatEl.textContent = beatNum;
                    beatNum++;
                    
                    timeline.appendChild(beatEl);
                }
            }
            
            // 스크롤 동기화
            const drumGridWrapper = document.getElementById('drumGridWrapper');
            drumGridWrapper.addEventListener('scroll', () => {
                timeline.scrollLeft = drumGridWrapper.scrollLeft;
            });
        }

        function initDrumGrid() {
            const track = tracks[currentTrackIndex];
            if (!track || track.type !== 'drum') return;
            
            const kit = DRUM_KITS[track.drumKit || 'acoustic'];
            const labels = document.getElementById('drumLabels');
            const grid = document.getElementById('drumGrid');
            
            labels.innerHTML = '';
            grid.innerHTML = '';
            
            // 타임라인 렌더링
            renderDrumTimeline();
            
            const totalSteps = totalBars * BEATS_PER_BAR * 4; // 1/16 steps
            const cellWidth = 28;
            
            kit.sounds.forEach((sound, rowIdx) => {
                // Label
                const label = document.createElement('div');
                label.className = 'drum-label';
                label.textContent = sound.name;
                label.addEventListener('click', () => playDrumSound(sound));
                labels.appendChild(label);
                
                // Row
                const row = document.createElement('div');
                row.className = 'drum-row';
                row.dataset.row = rowIdx;
                
                for (let step = 0; step < totalSteps; step++) {
                    const cell = document.createElement('div');
                    cell.className = 'drum-cell';
                    if ((step + 1) % 4 === 0) cell.classList.add('beat-start');
                    cell.dataset.row = rowIdx;
                    cell.dataset.step = step;
                    
                    if (track.pattern && track.pattern[rowIdx] && track.pattern[rowIdx][step]) {
                        cell.classList.add('active');
                    }
                    
                    // 도구별 클릭 처리
                    cell.addEventListener('click', (e) => {
                        handleDrumCellClick(cell, rowIdx, step, e.shiftKey);
                    });
                    
                    // 우클릭으로 삭제
                    cell.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        if (cell.classList.contains('active')) {
                            track.pattern[rowIdx][step] = false;
                            cell.classList.remove('active');
                            updateTrackPreviews();
                        }
                    });
                    row.appendChild(cell);
                }
                
                grid.appendChild(row);
            });
            
            grid.style.width = (totalSteps * cellWidth) + 'px';
            
            // 드래그 선택 설정
            setupDrumGridDragSelection();
        }

        function handleDrumCellClick(cell, row, step, shiftKey) {
            const track = tracks[currentTrackIndex];
            if (!track || !track.pattern) return;
            
            const cellKey = `${row}-${step}`;
            
            switch (currentDrumTool) {
                case 'pencil':
                    // 연필: 토글
                    toggleDrumCell(cell, row, step);
                    break;
                    
                case 'select':
                    // 선택: 셀 선택/해제
                    if (!shiftKey) {
                        clearDrumSelection();
                    }
                    if (selectedDrumCells.has(cellKey)) {
                        selectedDrumCells.delete(cellKey);
                        cell.classList.remove('selected');
                    } else {
                        selectedDrumCells.add(cellKey);
                        cell.classList.add('selected');
                    }
                    break;
                    
                case 'eraser':
                    // 지우개: 활성화된 셀 제거
                    if (cell.classList.contains('active')) {
                        if (!track.pattern[row]) return;
                        track.pattern[row][step] = false;
                        cell.classList.remove('active');
                        updateTrackPreviews();
                    }
                    break;
            }
        }

        // 드럼 그리드 드래그 선택
        let drumDragState = {
            active: false,
            startX: 0,
            startY: 0
        };

        function setupDrumGridDragSelection() {
            const gridWrapper = document.getElementById('drumGridWrapper');
            const grid = document.getElementById('drumGrid');
            const selectionBox = document.getElementById('drumSelectionBox');
            
            if (!gridWrapper || !grid) return;
            
            // 기존 리스너 제거를 위해 새 함수로 래핑
            gridWrapper.onmousedown = (e) => {
                if (currentDrumTool !== 'select') return;
                if (e.target.classList.contains('drum-cell')) return; // 셀 클릭은 별도 처리
                
                drumDragState.active = true;
                drumDragState.startX = e.clientX - gridWrapper.getBoundingClientRect().left + gridWrapper.scrollLeft;
                drumDragState.startY = e.clientY - gridWrapper.getBoundingClientRect().top + gridWrapper.scrollTop;
                
                if (!e.shiftKey) {
                    clearDrumSelection();
                }
                
                selectionBox.style.display = 'block';
                selectionBox.style.left = drumDragState.startX + 'px';
                selectionBox.style.top = drumDragState.startY + 'px';
                selectionBox.style.width = '0';
                selectionBox.style.height = '0';
            };
            
            document.addEventListener('mousemove', (e) => {
                if (!drumDragState.active) return;
                
                const rect = gridWrapper.getBoundingClientRect();
                const currentX = e.clientX - rect.left + gridWrapper.scrollLeft;
                const currentY = e.clientY - rect.top + gridWrapper.scrollTop;
                
                const left = Math.min(drumDragState.startX, currentX);
                const top = Math.min(drumDragState.startY, currentY);
                const width = Math.abs(currentX - drumDragState.startX);
                const height = Math.abs(currentY - drumDragState.startY);
                
                selectionBox.style.left = left + 'px';
                selectionBox.style.top = top + 'px';
                selectionBox.style.width = width + 'px';
                selectionBox.style.height = height + 'px';
            });
            
            document.addEventListener('mouseup', () => {
                if (!drumDragState.active) return;
                drumDragState.active = false;
                
                // 선택 박스와 겹치는 셀 선택
                const boxRect = selectionBox.getBoundingClientRect();
                document.querySelectorAll('.drum-cell').forEach(cell => {
                    const cellRect = cell.getBoundingClientRect();
                    if (cellRect.right > boxRect.left && cellRect.left < boxRect.right &&
                        cellRect.bottom > boxRect.top && cellRect.top < boxRect.bottom) {
                        const row = parseInt(cell.dataset.row);
                        const step = parseInt(cell.dataset.step);
                        const cellKey = `${row}-${step}`;
                        selectedDrumCells.add(cellKey);
                        cell.classList.add('selected');
                    }
                });
                
                selectionBox.style.display = 'none';
                
                if (selectedDrumCells.size > 0) {
                    showToast(`${selectedDrumCells.size}개 셀 선택됨`);
                }
            });
        }

        // 드럼 도구 관련
        let currentDrumTool = 'pencil'; // pencil, select, eraser
        let selectedDrumCells = new Set(); // 선택된 드럼 셀 저장 (row-step 형태)

        function setDrumTool(tool) {
            currentDrumTool = tool;
            document.getElementById('drumPencilTool').classList.toggle('active', tool === 'pencil');
            document.getElementById('drumSelectTool').classList.toggle('active', tool === 'select');
            document.getElementById('drumEraserTool').classList.toggle('active', tool === 'eraser');
            
            // 커서 변경
            const grid = document.getElementById('drumGrid');
            if (tool === 'pencil') grid.style.cursor = 'crosshair';
            else if (tool === 'select') grid.style.cursor = 'default';
            else if (tool === 'eraser') grid.style.cursor = 'not-allowed';
            
            // 선택 해제
            if (tool !== 'select') {
                clearDrumSelection();
            }
        }

        function clearDrumSelection() {
            selectedDrumCells.clear();
            document.querySelectorAll('.drum-cell.selected').forEach(c => c.classList.remove('selected'));
        }

        function deleteSelectedDrumCells() {
            const track = tracks[currentTrackIndex];
            if (!track || !track.pattern) return;
            
            selectedDrumCells.forEach(key => {
                const [row, step] = key.split('-').map(Number);
                if (track.pattern[row]) {
                    track.pattern[row][step] = false;
                }
            });
            
            // UI 업데이트
            document.querySelectorAll('.drum-cell.selected').forEach(cell => {
                cell.classList.remove('selected', 'active');
            });
            
            clearDrumSelection();
            updateTrackPreviews();
        }

        function toggleDrumCell(cell, row, step) {
            const track = tracks[currentTrackIndex];
            if (!track || !track.pattern) return;
            
            if (!track.pattern[row]) {
                track.pattern[row] = new Array(totalBars * BEATS_PER_BAR * 4).fill(false);
            }
            
            track.pattern[row][step] = !track.pattern[row][step];
            cell.classList.toggle('active');
            
            // Play sound when activating
            if (track.pattern[row][step]) {
                const kit = DRUM_KITS[track.drumKit || 'acoustic'];
                if (kit.sounds[row]) {
                    playDrumSound(kit.sounds[row]);
                }
            }
            
            updateTrackPreviews();
        }

        function playDrumSound(sound) {
            initAudio();
            
            const now = audioContext.currentTime;
            
            switch (sound.type) {
                case 'kick':
                case '808kick':
                    playKick(sound.freq, sound.type === '808kick');
                    break;
                case 'snare':
                    playSnare(sound.freq);
                    break;
                case 'hihat-closed':
                    playHiHat(0.05);
                    break;
                case 'hihat-open':
                    playHiHat(0.3);
                    break;
                case 'clap':
                    playClap();
                    break;
                case 'tom':
                    playTom(sound.freq);
                    break;
                case 'crash':
                case 'rim':
                case 'perc':
                case 'fx':
                    playPercussion(sound.freq, sound.type);
                    break;
            }
        }

        function playKick(freq, is808 = false) {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            
            osc.connect(gain);
            gain.connect(audioContext.destination);
            
            osc.frequency.setValueAtTime(is808 ? freq * 2 : freq * 4, audioContext.currentTime);
            osc.frequency.exponentialRampToValueAtTime(freq, audioContext.currentTime + 0.05);
            
            gain.gain.setValueAtTime(1, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + (is808 ? 0.5 : 0.2));
            
            osc.start();
            osc.stop(audioContext.currentTime + (is808 ? 0.5 : 0.2));
        }

        function playSnare(freq) {
            // Noise part
            const bufferSize = audioContext.sampleRate * 0.1;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }
            
            const noise = audioContext.createBufferSource();
            noise.buffer = buffer;
            
            const noiseFilter = audioContext.createBiquadFilter();
            noiseFilter.type = 'highpass';
            noiseFilter.frequency.value = 1000;
            
            const noiseGain = audioContext.createGain();
            noiseGain.gain.setValueAtTime(0.3, audioContext.currentTime);
            noiseGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.15);
            
            noise.connect(noiseFilter);
            noiseFilter.connect(noiseGain);
            noiseGain.connect(audioContext.destination);
            
            // Tone part
            const osc = audioContext.createOscillator();
            const oscGain = audioContext.createGain();
            osc.frequency.value = freq;
            oscGain.gain.setValueAtTime(0.5, audioContext.currentTime);
            oscGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);
            
            osc.connect(oscGain);
            oscGain.connect(audioContext.destination);
            
            noise.start();
            osc.start();
            osc.stop(audioContext.currentTime + 0.1);
        }

        function playHiHat(decay) {
            const bufferSize = audioContext.sampleRate * decay;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }
            
            const noise = audioContext.createBufferSource();
            noise.buffer = buffer;
            
            const filter = audioContext.createBiquadFilter();
            filter.type = 'highpass';
            filter.frequency.value = 7000;
            
            const gain = audioContext.createGain();
            gain.gain.setValueAtTime(0.3, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + decay);
            
            noise.connect(filter);
            filter.connect(gain);
            gain.connect(audioContext.destination);
            
            noise.start();
        }

        function playClap() {
            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    const bufferSize = audioContext.sampleRate * 0.05;
                    const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                    const data = buffer.getChannelData(0);
                    for (let j = 0; j < bufferSize; j++) {
                        data[j] = Math.random() * 2 - 1;
                    }
                    
                    const noise = audioContext.createBufferSource();
                    noise.buffer = buffer;
                    
                    const filter = audioContext.createBiquadFilter();
                    filter.type = 'bandpass';
                    filter.frequency.value = 1500;
                    filter.Q.value = 1;
                    
                    const gain = audioContext.createGain();
                    gain.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);
                    
                    noise.connect(filter);
                    filter.connect(gain);
                    gain.connect(audioContext.destination);
                    
                    noise.start();
                }, i * 10);
            }
        }

        function playTom(freq) {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            
            osc.connect(gain);
            gain.connect(audioContext.destination);
            
            osc.frequency.setValueAtTime(freq * 2, audioContext.currentTime);
            osc.frequency.exponentialRampToValueAtTime(freq, audioContext.currentTime + 0.05);
            
            gain.gain.setValueAtTime(0.6, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);
            
            osc.start();
            osc.stop(audioContext.currentTime + 0.3);
        }

        function playPercussion(freq, type) {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            
            osc.type = type === 'crash' ? 'square' : 'triangle';
            osc.frequency.value = freq;
            
            osc.connect(gain);
            gain.connect(audioContext.destination);
            
            const duration = type === 'crash' ? 0.5 : 0.15;
            gain.gain.setValueAtTime(0.3, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
            
            osc.start();
            osc.stop(audioContext.currentTime + duration);
        }

        function changeDrumKit() {
            const track = tracks[currentTrackIndex];
            if (!track || track.type !== 'drum') return;
            
            track.drumKit = document.getElementById('drumKitSelect').value;
            track.pattern = createEmptyDrumPattern();
            initDrumGrid();
        }

        function clearDrumPattern() {
            const track = tracks[currentTrackIndex];
            if (!track || track.type !== 'drum') return;
            
            track.pattern = createEmptyDrumPattern();
            initDrumGrid();
            updateTrackPreviews();
        }

        // Switch between Piano Roll and Record View
        function updateTrackView() {
            const track = tracks[currentTrackIndex];
            const pianoRollContainer = document.getElementById('pianoRollContainer');
            const noteTimelineWrapper = document.getElementById('noteTimelineWrapper');
            const recordView = document.getElementById('recordTrackView');
            const drumView = document.getElementById('drumTrackView');
            
            // 모든 뷰 숨기기
            pianoRollContainer.classList.add('hidden');
            noteTimelineWrapper.style.display = 'none';
            recordView.classList.remove('show');
            drumView.classList.remove('show');
            
            // 드럼 그리드 초기화
            document.getElementById('drumLabels').innerHTML = '';
            document.getElementById('drumGrid').innerHTML = '';
            document.getElementById('drumTimeline').innerHTML = '';
            
            // 레코드 뷰 초기화
            document.getElementById('clipsContainer').innerHTML = '';
            document.getElementById('waveformPlaceholder').style.display = '';
            document.getElementById('recordStatus').textContent = '녹음 대기';
            document.getElementById('recordTimeline').innerHTML = '';
            
            if (!track || currentTrackIndex < 0) {
                pianoRollContainer.classList.remove('hidden');
                noteTimelineWrapper.style.display = 'flex';
                return;
            }
            
            if (track.type === 'drum') {
                drumView.classList.add('show');
                document.getElementById('drumKitSelect').value = track.drumKit || 'acoustic';
                initDrumGrid();
            } else if (track.type === 'record') {
                recordView.classList.add('show');
                
                // 기존 편집 도구 초기화
                setEditTool('select');
                
                // 타임라인 렌더링
                renderRecordTimeline();
                
                // waveformArea 너비 설정
                const totalWidth = getGridTotalWidth();
                document.getElementById('waveformArea').style.width = totalWidth + 'px';
                
                // 클립이 있으면 렌더링
                if (track.clips && track.clips.length > 0) {
                    document.getElementById('waveformPlaceholder').style.display = 'none';
                    renderClips();
                    updateWaveformGrid();
                    const status = document.getElementById('recordStatus');
                    status.textContent = `클립 ${track.clips.length}개`;
                } else {
                    document.getElementById('waveformPlaceholder').style.display = '';
                    updateWaveformGrid();
                    const status = document.getElementById('recordStatus');
                    status.textContent = '녹음 대기';
                }
            } else {
                // note track
                pianoRollContainer.classList.remove('hidden');
                noteTimelineWrapper.style.display = 'flex';
            }
        }

        // 편집 도구
        let currentEditTool = 'select';
        let selectedClipId = null;
        let clipIdCounter = 0;

        function setEditTool(tool) {
            currentEditTool = tool;
            document.querySelectorAll('.record-btn.edit-tool').forEach(btn => btn.classList.remove('active'));
            const toolBtn = document.getElementById(tool + 'Tool');
            if (toolBtn) toolBtn.classList.add('active');
            
            const waveformArea = document.getElementById('waveformArea');
            waveformArea.classList.toggle('split-mode', tool === 'split');
        }

        // 클립 렌더링
        function renderClips() {
            const track = tracks[currentTrackIndex];
            if (!track || track.type !== 'record') return;
            
            const container = document.getElementById('clipsContainer');
            container.innerHTML = '';
            
            const beatWidth = getBeatWidth();
            const pixelsPerSecond = beatWidth * bpm / 60;
            
            // 전체 너비 계산
            let maxWidth = document.getElementById('waveformContainer').clientWidth;
            track.clips.forEach(clip => {
                const clipDuration = clip.trimEnd - clip.trimStart;
                const clipWidth = clipDuration * pixelsPerSecond;
                const clipEnd = clip.startBeat * beatWidth + clipWidth;
                maxWidth = Math.max(maxWidth, clipEnd + 100);
            });
            
            document.getElementById('waveformArea').style.width = maxWidth + 'px';
            
            track.clips.forEach(clip => {
                const clipEl = createClipElement(clip);
                container.appendChild(clipEl);
            });
        }

        function createClipElement(clip) {
            const beatWidth = getBeatWidth();
            const pixelsPerSecond = beatWidth * bpm / 60;
            const clipDuration = clip.trimEnd - clip.trimStart;
            const clipWidth = clipDuration * pixelsPerSecond;
            const clipLeft = clip.startBeat * beatWidth;
            
            const el = document.createElement('div');
            el.className = 'audio-clip' + (clip.id === selectedClipId ? ' selected' : '');
            el.dataset.clipId = clip.id;
            el.style.left = clipLeft + 'px';
            el.style.width = clipWidth + 'px';
            
            // 파형 캔버스
            const canvas = document.createElement('canvas');
            canvas.width = clipWidth;
            canvas.height = 100;
            drawClipWaveform(clip, canvas);
            el.appendChild(canvas);
            
            // 트림 핸들
            const leftHandle = document.createElement('div');
            leftHandle.className = 'clip-handle left';
            el.appendChild(leftHandle);
            
            const rightHandle = document.createElement('div');
            rightHandle.className = 'clip-handle right';
            el.appendChild(rightHandle);
            
            // 이벤트 설정
            setupClipInteractions(el, clip);
            
            return el;
        }

        function drawClipWaveform(clip, canvas) {
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.fillStyle = 'rgba(255, 51, 153, 0.1)';
            ctx.fillRect(0, 0, width, height);
            
            if (!clip.audioBuffer) return;
            
            const data = clip.audioBuffer.getChannelData(0);
            const sampleRate = clip.audioBuffer.sampleRate;
            const startSample = Math.floor(clip.trimStart * sampleRate);
            const endSample = Math.floor(clip.trimEnd * sampleRate);
            const totalSamples = endSample - startSample;
            
            const barWidth = 2;
            const gap = 1;
            const step = barWidth + gap;
            const barsCount = Math.floor(width / step);
            const samplesPerBar = Math.floor(totalSamples / barsCount);
            
            ctx.fillStyle = '#ff3399';
            const amp = height / 2;
            
            for (let i = 0; i < barsCount; i++) {
                let sum = 0;
                const barStartSample = startSample + i * samplesPerBar;
                
                for (let j = 0; j < samplesPerBar; j++) {
                    const idx = barStartSample + j;
                    if (idx < data.length) {
                        sum += Math.abs(data[idx]);
                    }
                }
                
                const average = samplesPerBar > 0 ? sum / samplesPerBar : 0;
                const barHeight = Math.max(2, average * height * 1.5);
                const x = i * step;
                const y = amp - barHeight / 2;
                
                ctx.fillRect(x, y, barWidth, barHeight);
            }
        }

        function setupClipInteractions(el, clip) {
            const leftHandle = el.querySelector('.clip-handle.left');
            const rightHandle = el.querySelector('.clip-handle.right');
            
            let isDragging = false;
            let isResizingLeft = false;
            let isResizingRight = false;
            let startX, startLeft, startWidth, startTrimStart, startTrimEnd, startBeat;
            
            // 클립 선택
            el.addEventListener('mousedown', (e) => {
                if (e.target.classList.contains('clip-handle')) return;
                selectClip(clip.id);
                
                if (currentEditTool === 'select') {
                    isDragging = true;
                    startX = e.clientX;
                    startLeft = parseFloat(el.style.left);
                    startBeat = clip.startBeat;
                    el.classList.add('dragging');
                }
            });
            
            el.addEventListener('touchstart', (e) => {
                if (e.target.classList.contains('clip-handle')) return;
                selectClip(clip.id);
                
                if (currentEditTool === 'select') {
                    isDragging = true;
                    startX = e.touches[0].clientX;
                    startLeft = parseFloat(el.style.left);
                    startBeat = clip.startBeat;
                    el.classList.add('dragging');
                }
            }, { passive: true });
            
            // 왼쪽 트림
            leftHandle.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                isResizingLeft = true;
                startX = e.clientX;
                startLeft = parseFloat(el.style.left);
                startWidth = parseFloat(el.style.width);
                startTrimStart = clip.trimStart;
                startBeat = clip.startBeat;
            });
            
            leftHandle.addEventListener('touchstart', (e) => {
                e.stopPropagation();
                isResizingLeft = true;
                startX = e.touches[0].clientX;
                startLeft = parseFloat(el.style.left);
                startWidth = parseFloat(el.style.width);
                startTrimStart = clip.trimStart;
                startBeat = clip.startBeat;
            }, { passive: true });
            
            // 오른쪽 트림
            rightHandle.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                isResizingRight = true;
                startX = e.clientX;
                startWidth = parseFloat(el.style.width);
                startTrimEnd = clip.trimEnd;
            });
            
            rightHandle.addEventListener('touchstart', (e) => {
                e.stopPropagation();
                isResizingRight = true;
                startX = e.touches[0].clientX;
                startWidth = parseFloat(el.style.width);
                startTrimEnd = clip.trimEnd;
            }, { passive: true });
            
            // 이동/리사이즈 처리
            const handleMove = (e) => {
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const dx = clientX - startX;
                const beatWidth = getBeatWidth();
                const pixelsPerSecond = beatWidth * bpm / 60;
                
                if (isDragging) {
                    const newLeft = Math.max(0, startLeft + dx);
                    const newBeat = newLeft / beatWidth;
                    clip.startBeat = newBeat;
                    el.style.left = newLeft + 'px';
                } else if (isResizingLeft) {
                    const maxDx = startWidth - 20; // 최소 너비
                    const clampedDx = Math.max(-startTrimStart * pixelsPerSecond, Math.min(maxDx, dx));
                    const newWidth = startWidth - clampedDx;
                    const newLeft = startLeft + clampedDx;
                    const timeDelta = clampedDx / pixelsPerSecond;
                    
                    clip.trimStart = Math.max(0, startTrimStart + timeDelta);
                    clip.startBeat = startBeat + timeDelta * bpm / 60;
                    el.style.left = newLeft + 'px';
                    el.style.width = newWidth + 'px';
                } else if (isResizingRight) {
                    const maxTrimEnd = clip.audioBuffer ? clip.audioBuffer.duration : startTrimEnd;
                    const maxDx = (maxTrimEnd - clip.trimStart) * pixelsPerSecond - startWidth;
                    const clampedDx = Math.max(-(startWidth - 20), Math.min(maxDx, dx));
                    const newWidth = startWidth + clampedDx;
                    const timeDelta = clampedDx / pixelsPerSecond;
                    
                    clip.trimEnd = Math.min(maxTrimEnd, startTrimEnd + timeDelta);
                    el.style.width = newWidth + 'px';
                }
            };
            
            const handleEnd = () => {
                if (isDragging || isResizingLeft || isResizingRight) {
                    isDragging = false;
                    isResizingLeft = false;
                    isResizingRight = false;
                    el.classList.remove('dragging');
                    
                    // 파형 다시 그리기
                    const canvas = el.querySelector('canvas');
                    canvas.width = parseFloat(el.style.width);
                    drawClipWaveform(clip, canvas);
                    
                    updateTrackPreviews();
                }
            };
            
            document.addEventListener('mousemove', handleMove);
            document.addEventListener('touchmove', handleMove, { passive: true });
            document.addEventListener('mouseup', handleEnd);
            document.addEventListener('touchend', handleEnd);
        }

        function selectClip(clipId) {
            selectedClipId = clipId;
            document.querySelectorAll('.audio-clip').forEach(el => {
                el.classList.toggle('selected', el.dataset.clipId == clipId);
            });
        }

        // 분할 기능
        function setupSplitMode() {
            const waveformArea = document.getElementById('waveformArea');
            const splitCursor = document.getElementById('splitCursor');
            
            waveformArea.addEventListener('mousemove', (e) => {
                if (currentEditTool !== 'split') return;
                const rect = waveformArea.getBoundingClientRect();
                const x = e.clientX - rect.left + waveformArea.parentElement.scrollLeft;
                splitCursor.style.left = x + 'px';
            });
            
            waveformArea.addEventListener('click', (e) => {
                if (currentEditTool !== 'split') return;
                
                const rect = waveformArea.getBoundingClientRect();
                const x = e.clientX - rect.left + waveformArea.parentElement.scrollLeft;
                const beatWidth = getBeatWidth();
                const splitBeat = x / beatWidth;
                
                // 해당 위치의 클립 찾기
                const track = tracks[currentTrackIndex];
                if (!track || !track.clips) return;
                
                const pixelsPerSecond = beatWidth * bpm / 60;
                
                for (let i = 0; i < track.clips.length; i++) {
                    const clip = track.clips[i];
                    const clipDuration = clip.trimEnd - clip.trimStart;
                    const clipStartX = clip.startBeat * beatWidth;
                    const clipEndX = clipStartX + clipDuration * pixelsPerSecond;
                    
                    if (x >= clipStartX && x <= clipEndX) {
                        splitClipAt(clip, x);
                        break;
                    }
                }
            });
        }

        function splitClipAt(clip, splitX) {
            const track = tracks[currentTrackIndex];
            const beatWidth = getBeatWidth();
            const pixelsPerSecond = beatWidth * bpm / 60;
            
            const clipStartX = clip.startBeat * beatWidth;
            const splitTime = clip.trimStart + (splitX - clipStartX) / pixelsPerSecond;
            
            // 분할이 클립 범위 내에 있는지 확인
            if (splitTime <= clip.trimStart || splitTime >= clip.trimEnd) return;
            
            // 새 클립 생성
            const newClip = {
                id: ++clipIdCounter,
                audioBuffer: clip.audioBuffer,
                startBeat: splitX / beatWidth,
                trimStart: splitTime,
                trimEnd: clip.trimEnd
            };
            
            // 기존 클립 수정
            clip.trimEnd = splitTime;
            
            // 배열에 추가
            track.clips.push(newClip);
            
            renderClips();
            updateTrackPreviews();
        }

        function deleteSelectedClip() {
            if (selectedClipId === null) return;
            
            const track = tracks[currentTrackIndex];
            if (!track || !track.clips) return;
            
            const idx = track.clips.findIndex(c => c.id === selectedClipId);
            if (idx !== -1) {
                track.clips.splice(idx, 1);
                selectedClipId = null;
                renderClips();
                updateTrackPreviews();
                
                if (track.clips.length === 0) {
                    document.getElementById('waveformPlaceholder').style.display = '';
                    document.getElementById('recordStatus').textContent = '녹음 대기';
                }
            }
        }

        // 파형 그리드 그리기
        function renderRecordTimeline() {
            const timeline = document.getElementById('recordTimeline');
            const waveformContainer = document.getElementById('waveformContainer');
            timeline.innerHTML = '';
            
            const beatWidth = getBeatWidth();
            const barWidth = getBarWidth();
            const totalWidth = getGridTotalWidth();
            
            let beatNum = 1;
            for (let bar = 0; bar < totalBars; bar++) {
                for (let beat = 0; beat < BEATS_PER_BAR; beat++) {
                    const beatEl = document.createElement('div');
                    beatEl.className = 'record-timeline-beat';
                    beatEl.style.width = beatWidth + 'px';
                    beatEl.style.minWidth = beatWidth + 'px';
                    
                    // 마디의 마지막 비트 뒤에 구분선
                    if (beat === BEATS_PER_BAR - 1) {
                        beatEl.classList.add('bar-end');
                    }
                    // 마디의 첫 비트 강조
                    if (beat === 0) {
                        beatEl.classList.add('bar-first');
                    }
                    beatEl.textContent = beatNum;
                    beatNum++;
                    
                    timeline.appendChild(beatEl);
                }
            }
            
            // 스크롤 동기화
            const timelineWrapper = document.querySelector('.record-timeline-wrapper');
            waveformContainer.addEventListener('scroll', () => {
                timelineWrapper.scrollLeft = waveformContainer.scrollLeft;
            });
        }

        function updateWaveformGrid() {
            const grid = document.getElementById('waveformGrid');
            const area = document.getElementById('waveformArea');
            const width = parseFloat(area.style.width) || area.clientWidth;
            const height = area.clientHeight;
            
            grid.innerHTML = '';
            
            // 타임라인 렌더링
            renderRecordTimeline();
            
            const beatWidth = getBeatWidth();
            const barWidth = getBarWidth();
            
            // 비트 라인
            for (let x = 0; x < width; x += beatWidth) {
                const line = document.createElement('div');
                line.className = 'grid-line line-beat';
                line.style.cssText = `position:absolute;top:0;left:${x}px;width:1px;height:100%;background:rgba(255,255,255,0.1);`;
                grid.appendChild(line);
            }
            
            // 바 라인
            for (let x = 0; x < width; x += barWidth) {
                const line = document.createElement('div');
                line.className = 'grid-line line-bar';
                line.style.cssText = `position:absolute;top:0;left:${x}px;width:2px;height:100%;background:rgba(255,255,255,0.3);`;
                grid.appendChild(line);
            }
        }

        // Recording
        let isRecording = false;
        let mediaRecorder = null;
        let recordedChunks = [];
        let recordingStream = null;
        let micStream = null; // 전역 마이크 스트림 (재사용)
        let analyser = null;
        let recordingAnimationFrame = null;
        let recordingStartTime = 0;

        // 마이크 스트림 가져오기 (한 번만 권한 요청)
        async function getMicStream() {
            if (micStream && micStream.active) {
                return micStream;
            }
            micStream = await navigator.mediaDevices.getUserMedia({ 
                audio: {
                    echoCancellation: true,
                    noiseSuppression: true,
                    autoGainControl: true
                } 
            });
            return micStream;
        }

        async function toggleRecording() {
            if (isRecording) {
                stopRecording();
            } else {
                await startRecording();
            }
        }

        async function startRecording() {
            try {
                // 마이크 스트림 가져오기 (이미 있으면 재사용)
                recordingStream = await getMicStream();
                
                initAudio();
                
                // 분석기 설정 (실시간 파형용)
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                const source = audioContext.createMediaStreamSource(recordingStream);
                source.connect(analyser);
                
                // MediaRecorder 설정
                const mimeType = MediaRecorder.isTypeSupported('audio/webm') ? 'audio/webm' : 'audio/mp4';
                mediaRecorder = new MediaRecorder(recordingStream, { mimeType });
                recordedChunks = [];
                
                mediaRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) {
                        recordedChunks.push(e.data);
                    }
                };
                
                mediaRecorder.onstop = async () => {
                    // 실시간 캔버스 제거
                    const liveCanvas = document.getElementById('liveRecordCanvas');
                    if (liveCanvas) liveCanvas.remove();
                    await processRecording();
                };
                
                // 플레이헤드를 0으로 리셋
                playheadPosition = 0;
                updatePlayheadUI();
                
                // 녹음 시작
                mediaRecorder.start(100);
                isRecording = true;
                recordingStartTime = Date.now();
                
                // UI 업데이트
                const btn = document.getElementById('recBtn');
                const status = document.getElementById('recordStatus');
                btn.classList.add('recording');
                status.textContent = '● 녹음 중...';
                status.classList.add('recording');
                
                // placeholder 숨기기
                document.getElementById('waveformPlaceholder').style.display = 'none';
                
                // 기존 실시간 캔버스 제거
                const existingLive = document.getElementById('liveRecordCanvas');
                if (existingLive) existingLive.remove();
                
                // 클립 컨테이너 초기화
                const container = document.getElementById('waveformContainer');
                const waveformArea = document.getElementById('waveformArea');
                waveformArea.style.width = container.clientWidth + 'px';
                
                // 그리드 업데이트
                updateWaveformGrid();
                
                // 실시간 파형 그리기 (플레이헤드도 함께 움직임)
                drawLiveWaveform();
                
            } catch (err) {
                console.error('마이크 접근 오류:', err);
                alert('마이크 접근이 거부되었습니다. 브라우저 설정에서 마이크 권한을 허용해주세요.');
            }
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }
            
            // 스트림은 유지 (권한 재요청 방지)
            
            if (recordingAnimationFrame) {
                cancelAnimationFrame(recordingAnimationFrame);
                recordingAnimationFrame = null;
            }
            
            isRecording = false;
            
            // UI 업데이트
            const btn = document.getElementById('recBtn');
            const status = document.getElementById('recordStatus');
            btn.classList.remove('recording');
            status.textContent = '처리 중...';
            status.classList.remove('recording');
        }

        async function processRecording() {
            try {
                const blob = new Blob(recordedChunks, { type: recordedChunks[0]?.type || 'audio/webm' });
                const arrayBuffer = await blob.arrayBuffer();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                
                // 새 클립 생성
                const newClip = {
                    id: ++clipIdCounter,
                    audioBuffer: audioBuffer,
                    startBeat: 0, // 처음부터 시작
                    trimStart: 0,
                    trimEnd: audioBuffer.duration
                };
                
                // 클립 배열에 추가
                if (!tracks[currentTrackIndex].clips) {
                    tracks[currentTrackIndex].clips = [];
                }
                tracks[currentTrackIndex].clips.push(newClip);
                
                // 플레이헤드를 0으로 리셋
                playheadPosition = 0;
                updatePlayheadUI();
                updateTimeDisplay(0);
                
                // 클립 렌더링
                document.getElementById('waveformPlaceholder').style.display = 'none';
                renderClips();
                updateWaveformGrid();
                
                // 트랙 프리뷰 업데이트
                updateTrackPreviews();
                
                // UI 업데이트
                const status = document.getElementById('recordStatus');
                const duration = audioBuffer.duration.toFixed(1);
                status.textContent = `녹음 완료 (${duration}초)`;
                
            } catch (err) {
                console.error('녹음 처리 오류:', err);
                const status = document.getElementById('recordStatus');
                status.textContent = '녹음 실패';
            }
        }

        function drawLiveWaveform() {
            if (!isRecording || !analyser) return;
            
            const container = document.getElementById('waveformContainer');
            const containerHeight = container.clientHeight;
            
            // 실시간 녹음 캔버스 가져오기 또는 생성
            let liveCanvas = document.getElementById('liveRecordCanvas');
            if (!liveCanvas) {
                liveCanvas = document.createElement('canvas');
                liveCanvas.id = 'liveRecordCanvas';
                liveCanvas.width = container.clientWidth;
                liveCanvas.height = Math.floor(containerHeight * 0.8);
                liveCanvas.style.cssText = `position:absolute;top:10%;height:80%;left:0;background:rgba(255,51,153,0.2);border:2px solid var(--accent-pink);border-radius:4px;`;
                document.getElementById('clipsContainer').appendChild(liveCanvas);
            }
            
            const ctx = liveCanvas.getContext('2d');
            
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteFrequencyData(dataArray);
            
            // 녹음 시간 계산 (BPM 기반 픽셀/초)
            const elapsed = (Date.now() - recordingStartTime) / 1000;
            const beatWidth = getBeatWidth();
            const pixelsPerSecond = beatWidth * bpm / 60;
            const currentX = elapsed * pixelsPerSecond;
            
            // 플레이헤드 위치 업데이트 (녹음 중에도 움직이게)
            playheadPosition = currentX;
            updatePlayheadUI();
            
            // 캔버스 확장 필요시
            if (currentX > liveCanvas.width - 50) {
                const newWidth = Math.max(liveCanvas.width + 200, currentX + 100);
                const imageData = ctx.getImageData(0, 0, liveCanvas.width, liveCanvas.height);
                liveCanvas.width = newWidth;
                liveCanvas.style.width = newWidth + 'px';
                document.getElementById('waveformArea').style.width = (newWidth + 100) + 'px';
                ctx.putImageData(imageData, 0, 0);
            }
            
            // 평균 볼륨 계산
            let sum = 0;
            for (let i = 0; i < bufferLength; i++) {
                sum += dataArray[i];
            }
            const average = sum / bufferLength;
            const normalizedHeight = (average / 255) * (liveCanvas.height * 0.8);
            
            // 파형 바 그리기
            const barWidth = 2;
            const centerY = liveCanvas.height / 2;
            
            ctx.fillStyle = '#ff3399';
            ctx.fillRect(currentX, centerY - normalizedHeight / 2, barWidth, Math.max(2, normalizedHeight));
            
            // 트랙 프리뷰에도 실시간 표시
            drawLiveTrackPreview(elapsed, average / 255);
            
            // 녹음 시간 표시
            const status = document.getElementById('recordStatus');
            status.textContent = `● 녹음 중... ${elapsed.toFixed(1)}초`;
            
            // 시간 디스플레이 업데이트
            updateTimeDisplay(elapsed);
            
            recordingAnimationFrame = requestAnimationFrame(drawLiveWaveform);
        }

        function drawLiveTrackPreview(elapsed, level) {
            const c = document.querySelector(`.track-notes-preview[data-track-id="${currentTrackIndex}"]`);
            if (!c) return;
            
            let canvas = c.querySelector('.live-preview-canvas');
            if (!canvas) {
                // 캔버스 생성
                const inner = c.querySelector('.track-preview-inner');
                if (!inner) return;
                canvas = document.createElement('canvas');
                canvas.className = 'live-preview-canvas';
                canvas.style.position = 'absolute';
                canvas.style.top = '0';
                canvas.style.left = '0';
                canvas.width = c.clientWidth;
                canvas.height = c.clientHeight;
                inner.appendChild(canvas);
            }
            
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            
            // BPM 기반 위치 계산
            const beatWidth = getBeatWidth();
            const gridTotalWidth = getGridTotalWidth();
            const pixelsPerSecond = beatWidth * bpm / 60;
            const currentX = elapsed * pixelsPerSecond;
            const x = (currentX / gridTotalWidth) * w;
            
            if (x < w) {
                const barHeight = level * h * 0.8;
                const centerY = h / 2;
                
                ctx.fillStyle = tracks[currentTrackIndex].color;
                ctx.fillRect(x, centerY - barHeight / 2, 2, Math.max(1, barHeight));
            }
        }

        function drawWaveform(audioBuffer) {
            const canvas = document.getElementById('waveformCanvas');
            const ctx = canvas.getContext('2d');
            const container = document.getElementById('waveformArea').parentElement;
            
            // BPM 기반 캔버스 크기 설정
            const beatWidth = getBeatWidth();
            const barWidth = getBarWidth();
            const pixelsPerSecond = beatWidth * bpm / 60;
            const width = Math.max(container.clientWidth, Math.ceil(audioBuffer.duration * pixelsPerSecond));
            const height = container.clientHeight;
            
            canvas.width = width;
            canvas.height = height;
            
            // waveformArea 너비도 조정
            document.getElementById('waveformArea').style.width = width + 'px';
            
            const data = audioBuffer.getChannelData(0);
            const sampleRate = audioBuffer.sampleRate;
            const amp = height / 2;
            
            // 배경
            ctx.fillStyle = '#1a1a22';
            ctx.fillRect(0, 0, width, height);
            
            // 그리드 라인 그리기 (비트 단위 - 노트 그리드와 동일)
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i < width; i += beatWidth) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, height);
                ctx.stroke();
            }
            // 바 단위 (4비트마다)
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            for (let i = 0; i < width; i += barWidth) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, height);
                ctx.stroke();
            }
            
            // 파형 그리기 (시간 기반 정확한 매핑)
            ctx.fillStyle = '#ff3399';
            
            const waveBarWidth = 2;
            const gap = 1;
            const step = waveBarWidth + gap;
            
            for (let x = 0; x < width; x += step) {
                // x 픽셀 위치에 해당하는 시간(초)
                const timeInSeconds = x / pixelsPerSecond;
                // 해당 시간의 샘플 인덱스
                const sampleIndex = Math.floor(timeInSeconds * sampleRate);
                // 다음 막대까지의 샘플 개수
                const nextTimeInSeconds = (x + step) / pixelsPerSecond;
                const nextSampleIndex = Math.floor(nextTimeInSeconds * sampleRate);
                const samplesInBar = nextSampleIndex - sampleIndex;
                
                // 해당 구간의 평균 볼륨 계산
                let sum = 0;
                for (let i = 0; i < samplesInBar; i++) {
                    const idx = sampleIndex + i;
                    if (idx < data.length) {
                        sum += Math.abs(data[idx]);
                    }
                }
                
                const average = samplesInBar > 0 ? sum / samplesInBar : 0;
                const waveBarHeight = Math.max(2, average * height * 1.5);
                const y = amp - waveBarHeight / 2;
                
                ctx.fillRect(x, y, waveBarWidth, waveBarHeight);
            }
            
            // 중앙선
            ctx.strokeStyle = 'rgba(255,51,153,0.3)';
            ctx.beginPath();
            ctx.moveTo(0, amp);
            ctx.lineTo(width, amp);
            ctx.stroke();
        }

        // 녹음된 오디오 재생
        let activeAudioSources = [];

        // 클립 재생
        function playClip(clip, playbackStartTime) {
            if (!clip.audioBuffer) return null;
            
            const source = audioContext.createBufferSource();
            const gainNode = audioContext.createGain();
            
            source.buffer = clip.audioBuffer;
            source.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            const track = tracks[currentTrackIndex];
            gainNode.gain.value = (track && track.muted) ? 0 : 1;
            
            // 클립의 트림된 부분만 재생
            const duration = clip.trimEnd - clip.trimStart;
            const offset = Math.max(0, playbackStartTime - clip.trimStart);
            const startFrom = clip.trimStart + offset;
            const playDuration = duration - offset;
            
            if (playDuration > 0) {
                source.start(0, startFrom, playDuration);
                activeAudioSources.push(source);
            }
            
            return source;
        }

        function playRecordedAudio(track, startOffset = 0) {
            if (!track.clips || track.clips.length === 0) return;
            
            const beatWidth = getBeatWidth();
            const pixelsPerSecond = beatWidth * bpm / 60;
            
            track.clips.forEach(clip => {
                // 클립의 시작 시간 (초)
                const clipStartTime = clip.startBeat * 60 / bpm;
                const clipDuration = clip.trimEnd - clip.trimStart;
                const clipEndTime = clipStartTime + clipDuration;
                
                // 현재 재생 위치가 클립 범위 내에 있는지 확인
                if (startOffset < clipEndTime) {
                    const source = audioContext.createBufferSource();
                    const gainNode = audioContext.createGain();
                    
                    source.buffer = clip.audioBuffer;
                    source.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    gainNode.gain.value = track.muted ? 0 : 1;
                    
                    if (startOffset >= clipStartTime) {
                        // 현재 위치가 클립 중간에 있음
                        const offsetInClip = startOffset - clipStartTime;
                        const playFrom = clip.trimStart + offsetInClip;
                        const playDuration = clip.trimEnd - playFrom;
                        if (playDuration > 0) {
                            source.start(0, playFrom, playDuration);
                            activeAudioSources.push(source);
                        }
                    } else {
                        // 클립이 아직 시작되지 않음 - 지연 후 재생
                        const delay = clipStartTime - startOffset;
                        source.start(audioContext.currentTime + delay, clip.trimStart, clipDuration);
                        activeAudioSources.push(source);
                    }
                }
            });
        }

        function stopAllRecordedAudio() {
            activeAudioSources.forEach(source => {
                try { source.stop(); } catch(e) {}
            });
            activeAudioSources = [];
        }

        function deleteRecording() {
            // 선택된 클립 삭제 또는 전체 삭제
            if (selectedClipId !== null) {
                deleteSelectedClip();
            } else {
                // 전체 삭제
                const track = tracks[currentTrackIndex];
                if (track && track.type === 'record') {
                    track.clips = [];
                    
                    // UI 초기화
                    document.getElementById('waveformPlaceholder').style.display = '';
                    document.getElementById('waveformArea').style.width = '100%';
                    document.getElementById('clipsContainer').innerHTML = '';
                    
                    const status = document.getElementById('recordStatus');
                    status.textContent = '녹음 대기';
                    
                    updateTrackPreviews();
                }
            }
        }

        function createNewProject() {
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('appContainer').classList.add('show');
            initInstrumentDropdown();
            initProject();
            initDatabase().catch(e => console.log('DB init error:', e));
            
            // 샘플러 로드 (백그라운드)
            initSamplers().catch(e => console.log('Sampler init error:', e));
        }

        function resetProject() {
            stopPlayback();
            tracks = [];
            currentTrackIndex = -1;
            bpm = 120;
            totalBars = 16; // 마디 수 초기화
            document.getElementById('bpmInput').value = 120;
            document.getElementById('gridSelect').value = 4;
            gridResolution = 4;
            playheadPosition = 0;
            document.getElementById('trackSelect').innerHTML = '';
            initTimeline();
            initPianoRoll();
            rebuildTrackUI();
            renderNotes();
            updateTrackPreviews();
            updateEmptyState();
            updateTimeDisplay(0);
            updatePlayheadUI();
        }

        function initProject() {
            tracks = []; // 빈 프로젝트로 시작
            currentTrackIndex = -1;
            initTimeline();
            initPianoRoll();
            setupGridDrawing();
            setupGlobalNoteInteractions(); // 노트 인터랙션 설정
            setupSplitMode(); // 분할 모드 설정
            syncScroll();
            rebuildTrackUI();
            updateTrackPreviews();
            updateEmptyState();
            document.getElementById('trackSelect').innerHTML = '';
        }

        function rebuildTrackUI() {
            const c = document.getElementById('tracksContainer');
            c.innerHTML = '';
            tracks.forEach((t, i) => {
                const instrumentOptions = Object.keys(INSTRUMENTS).map(key => 
                    `<option value="${key}" ${t.instrument === key ? 'selected' : ''}>${INSTRUMENTS[key].name}</option>`
                ).join('');
                
                const trackType = t.type || 'note';
                const typeIcon = trackType === 'note' ? '🎹' : '🎙️';
                const typeClass = trackType === 'note' ? 'note' : 'record';
                
                c.insertAdjacentHTML('beforeend', `
                    <div class="audio-track ${i === currentTrackIndex ? 'active' : ''}" data-track-id="${i}">
                        <div class="track-info">
                            <div style="display:flex;align-items:center;">
                                <input type="text" class="track-name-input" value="${t.name}" maxlength="12" style="color:${t.color};flex:1;">
                                <span class="track-type-indicator ${typeClass}">${typeIcon}</span>
                            </div>
                            ${trackType === 'note' ? `
                            <select class="track-instrument-select" onchange="changeTrackInstrument(${i}, this.value)">
                                ${instrumentOptions}
                            </select>
                            ` : `<div style="font-size:8px;color:var(--text-secondary);padding:2px 0;">오디오 트랙</div>`}
                            <div class="track-controls">
                                <button class="track-btn solo ${t.solo?'active':''}" onclick="toggleSolo(this,${i})">S</button>
                                <button class="track-btn mute ${t.muted?'active':''}" onclick="toggleMute(this,${i})">M</button>
                                <button class="track-btn delete" onclick="deleteAudioTrack(this)">✕</button>
                            </div>
                        </div>
                        <div class="track-notes-preview" data-track-id="${i}" onclick="selectTrackFromPreview(${i})">
                            <div class="track-preview-inner"></div>
                            <div class="track-playhead" style="left:0;"></div>
                        </div>
                    </div>
                `);
            });
        }

        function initTimeline() {
            const t = document.getElementById('timelineInner');
            t.innerHTML = '';
            t.style.width = getGridTotalWidth() + 'px';
            const beatWidth = getBeatWidth();
            
            let beatNum = 1;
            for (let bar = 0; bar < totalBars; bar++) {
                for (let beat = 0; beat < BEATS_PER_BAR; beat++) {
                    const b = document.createElement('div');
                    b.className = 'timeline-beat';
                    b.style.width = b.style.minWidth = beatWidth + 'px';
                    
                    // 마디의 마지막 비트(4번째) 뒤에 구분선
                    if (beat === BEATS_PER_BAR - 1) {
                        b.classList.add('bar-end');
                    }
                    // 마디의 첫 번째 비트 강조
                    if (beat === 0) {
                        b.classList.add('bar-first');
                    }
                    b.textContent = beatNum;
                    beatNum++;
                    
                    t.appendChild(b);
                }
            }
        }

        function initPianoRoll() {
            const keys = document.getElementById('pianoKeys');
            const grid = document.getElementById('pianoGrid');
            keys.innerHTML = '';
            grid.innerHTML = '<div class="playhead" id="playhead"></div>';
            grid.style.width = getGridTotalWidth() + 'px';
            grid.style.height = totalRows * CELL_HEIGHT + 'px';

            let row = 0;
            octaves.forEach(oct => {
                for (let i = 11; i >= 0; i--) {
                    const name = keyNames[i], full = name + oct;
                    const isBlack = blackKeyIndices.includes(i), isC = i === 0;

                    const key = document.createElement('div');
                    key.className = 'piano-key ' + (isBlack ? 'black' : 'white');
                    key.textContent = full;
                    key.dataset.note = full;
                    key.dataset.row = row;
                    key.addEventListener('touchstart', e => { e.preventDefault(); playNotePreview(key); }, { passive: false });
                    key.addEventListener('touchend', () => stopNotePreview(key));
                    key.addEventListener('mousedown', () => playNotePreview(key));
                    key.addEventListener('mouseup', () => stopNotePreview(key));
                    key.addEventListener('mouseleave', () => stopNotePreview(key));
                    keys.appendChild(key);

                    const r = document.createElement('div');
                    r.className = 'grid-row' + (isBlack ? ' black-key' : '') + (isC ? ' c-note' : '');
                    r.dataset.note = full;
                    r.dataset.row = row;
                    r.style.width = getGridTotalWidth() + 'px';
                    grid.appendChild(r);
                    row++;
                }
            });
            
            // 그리드 라인 오버레이 그리기
            updateGridLines();
            
            grid.addEventListener('contextmenu', e => e.preventDefault());
            renderNotes();
        }
        
        // 그리드 라인 그리기
        function updateGridLines() {
            const grid = document.getElementById('pianoGrid');
            
            // 기존 라인 제거
            grid.querySelectorAll('.grid-line').forEach(el => el.remove());
            
            const beatWidth = getBeatWidth();
            const barWidth = getBarWidth();
            const snapWidth = getSnapPixels();
            const totalWidth = getGridTotalWidth();
            
            // 1/32 라인 (가장 연함)
            if (gridResolution === 8) {
                for (let x = 0; x < totalWidth; x += BASE_CELL_WIDTH) {
                    if (x % snapWidth !== 0) continue; // 스냅 단위만
                    if (x % (beatWidth / 4) === 0) continue; // 1/16 라인은 스킵
                    const line = document.createElement('div');
                    line.className = 'grid-line line-32';
                    line.style.left = x + 'px';
                    grid.appendChild(line);
                }
            }
            
            // 1/16 라인
            if (gridResolution >= 4) {
                for (let x = 0; x < totalWidth; x += beatWidth / 4) {
                    if (x % (beatWidth / 2) === 0) continue; // 1/8 라인은 스킵
                    const line = document.createElement('div');
                    line.className = 'grid-line line-16';
                    line.style.left = x + 'px';
                    grid.appendChild(line);
                }
            }
            
            // 1/8 라인
            if (gridResolution >= 2) {
                for (let x = 0; x < totalWidth; x += beatWidth / 2) {
                    if (x % beatWidth === 0) continue; // 비트 라인은 스킵
                    const line = document.createElement('div');
                    line.className = 'grid-line line-8';
                    line.style.left = x + 'px';
                    grid.appendChild(line);
                }
            }
            
            // 비트 라인 (1/4)
            for (let x = 0; x < totalWidth; x += beatWidth) {
                if (x % barWidth === 0) continue; // 마디 라인은 스킵
                const line = document.createElement('div');
                line.className = 'grid-line line-beat';
                line.style.left = x + 'px';
                grid.appendChild(line);
            }
            
            // 마디 라인
            for (let x = 0; x <= totalWidth; x += barWidth) {
                const line = document.createElement('div');
                line.className = 'grid-line line-bar';
                line.style.left = x + 'px';
                grid.appendChild(line);
            }
            
            // 마디 추가 버튼
            let addBarBtn = grid.querySelector('.add-bar-btn');
            if (!addBarBtn) {
                addBarBtn = document.createElement('div');
                addBarBtn.className = 'add-bar-btn';
                addBarBtn.innerHTML = '+4';
                addBarBtn.title = '4마디 추가';
                addBarBtn.onclick = () => addBars(4);
                grid.appendChild(addBarBtn);
            }
            addBarBtn.style.left = (totalWidth - 30) + 'px';
        }
        
        // 마디 추가 함수
        function addBars(count) {
            totalBars += count;
            
            // 그리드 크기 업데이트
            const grid = document.getElementById('pianoGrid');
            grid.style.width = getGridTotalWidth() + 'px';
            
            // 각 행 너비 업데이트
            grid.querySelectorAll('.grid-row').forEach(row => {
                row.style.width = getGridTotalWidth() + 'px';
            });
            
            // 타임라인 업데이트
            initTimeline();
            
            // 그리드 라인 다시 그리기
            updateGridLines();
            
            // 트랙 프리뷰 업데이트
            updateTrackPreviews();
        }
        
        // 그리드 해상도 변경
        function changeGridResolution() {
            const gridSelectMini = document.getElementById('gridSelectMini');
            gridResolution = parseInt(gridSelectMini.value);
            updateGridLines();
        }
        
        // 빈 상태 업데이트
        function updateEmptyState() {
            const emptyState = document.getElementById('emptyState');
            const pianoKeys = document.getElementById('pianoKeys');
            const pianoGridWrapper = document.getElementById('pianoGridWrapper');
            
            if (tracks.length === 0) {
                emptyState.classList.add('show');
                pianoKeys.style.opacity = '0.3';
                pianoGridWrapper.style.opacity = '0.3';
            } else {
                emptyState.classList.remove('show');
                pianoKeys.style.opacity = '1';
                pianoGridWrapper.style.opacity = '1';
            }
        }

        function setupGridDrawing() {
            const grid = document.getElementById('pianoGrid');
            let selectionBox = null;
            let isSelecting = false;
            let isErasing = false;
            let selectStartX = 0, selectStartY = 0;

            const startDraw = (e) => {
                if (e.button === 2) return;
                if (tracks.length === 0 || currentTrackIndex < 0) return;
                if (tracks[currentTrackIndex].type !== 'note') return;
                
                e.preventDefault();
                
                const wrapper = document.getElementById('pianoGridWrapper');
                const rect = wrapper.getBoundingClientRect();
                const touch = e.touches ? e.touches[0] : e;
                const x = touch.clientX - rect.left + wrapper.scrollLeft;
                const y = touch.clientY - rect.top + wrapper.scrollTop;
                
                // 행 계산
                const row = Math.floor(y / CELL_HEIGHT);
                if (row < 0 || row >= totalRows) return;
                
                // 비트 계산 (스냅 적용)
                const beatWidth = getBeatWidth();
                const snapPixels = getSnapPixels();
                const snappedX = Math.floor(x / snapPixels) * snapPixels;
                const beat = snappedX / beatWidth;
                
                // 노트 이름 찾기
                const rowEl = grid.querySelector(`.grid-row[data-row="${row}"]`);
                if (!rowEl) return;
                const noteName = rowEl.dataset.note;
                
                const t = tracks[currentTrackIndex];
                
                // 선택 도구: 드래그 선택 시작
                if (currentNoteTool === 'select') {
                    const clickedNote = t.notes.find(n => 
                        n.row === row && n.beat <= beat && n.beat + n.length > beat);
                    
                    if (clickedNote) {
                        // 노트 위에서 클릭 - 개별 선택
                        if (!e.shiftKey) {
                            t.notes.forEach(n => n.selected = false);
                        }
                        clickedNote.selected = !clickedNote.selected;
                        renderNotes();
                    } else {
                        // 빈 공간에서 드래그 시작 - 박스 선택
                        if (!e.shiftKey) {
                            deselectAllNotes();
                        }
                        isSelecting = true;
                        selectStartX = x;
                        selectStartY = y;
                        
                        // 선택 박스 생성
                        selectionBox = document.createElement('div');
                        selectionBox.className = 'selection-box';
                        selectionBox.style.left = x + 'px';
                        selectionBox.style.top = y + 'px';
                        selectionBox.style.width = '0px';
                        selectionBox.style.height = '0px';
                        grid.appendChild(selectionBox);
                    }
                    return;
                }
                
                // 지우개 도구: 드래그하면서 노트 삭제
                if (currentNoteTool === 'eraser') {
                    isErasing = true;
                    // 현재 위치의 노트 삭제
                    const noteIdx = t.notes.findIndex(n => 
                        n.row === row && n.beat <= beat && n.beat + n.length > beat);
                    if (noteIdx !== -1) {
                        t.notes.splice(noteIdx, 1);
                        renderNotes();
                        updateTrackPreviews();
                    }
                    return;
                }
                
                // 연필 도구: 노트 그리기
                isDrawing = true;
                drawStartBeat = beat;
                drawStartRow = row;
                drawStartNote = noteName;
                
                if (auditionEnabled) startSustainedNote(drawStartNote);
                createPreviewNote(row, beat, getSnapUnit());
            };

            const moveDraw = (e) => {
                const touch = e.touches ? e.touches[0] : e;
                const wrapper = document.getElementById('pianoGridWrapper');
                const rect = wrapper.getBoundingClientRect();
                const x = touch.clientX - rect.left + wrapper.scrollLeft;
                const y = touch.clientY - rect.top + wrapper.scrollTop;
                
                // 지우개 드래그 중
                if (isErasing) {
                    const row = Math.floor(y / CELL_HEIGHT);
                    const beatWidth = getBeatWidth();
                    const beat = x / beatWidth;
                    
                    const t = tracks[currentTrackIndex];
                    if (t && t.notes) {
                        const noteIdx = t.notes.findIndex(n => 
                            n.row === row && n.beat <= beat && n.beat + n.length > beat);
                        if (noteIdx !== -1) {
                            t.notes.splice(noteIdx, 1);
                            renderNotes();
                            updateTrackPreviews();
                        }
                    }
                    return;
                }
                
                // 드래그 선택 중
                if (isSelecting && selectionBox) {
                    const minX = Math.min(selectStartX, x);
                    const maxX = Math.max(selectStartX, x);
                    const minY = Math.min(selectStartY, y);
                    const maxY = Math.max(selectStartY, y);
                    
                    selectionBox.style.left = minX + 'px';
                    selectionBox.style.top = minY + 'px';
                    selectionBox.style.width = (maxX - minX) + 'px';
                    selectionBox.style.height = (maxY - minY) + 'px';
                    return;
                }
                
                // 노트 그리기 중
                if (!isDrawing) return;
                
                const beatWidth = getBeatWidth();
                const snapPixels = getSnapPixels();
                const snappedEndX = Math.ceil(x / snapPixels) * snapPixels;
                const endBeat = snappedEndX / beatWidth;
                const len = Math.max(getSnapUnit(), endBeat - drawStartBeat);
                
                if (previewNote) {
                    previewNote.style.width = (len * beatWidth - 2) + 'px';
                }
            };

            const endDraw = () => {
                // 지우개 드래그 종료
                if (isErasing) {
                    isErasing = false;
                    return;
                }
                
                // 드래그 선택 종료
                if (isSelecting && selectionBox) {
                    const beatWidth = getBeatWidth();
                    const t = tracks[currentTrackIndex];
                    
                    // 선택 박스 범위 계산
                    const boxLeft = parseFloat(selectionBox.style.left);
                    const boxTop = parseFloat(selectionBox.style.top);
                    const boxRight = boxLeft + parseFloat(selectionBox.style.width);
                    const boxBottom = boxTop + parseFloat(selectionBox.style.height);
                    
                    // 박스 안에 있는 노트 선택
                    if (t && t.notes) {
                        t.notes.forEach(n => {
                            const noteLeft = n.beat * beatWidth;
                            const noteRight = noteLeft + n.length * beatWidth;
                            const noteTop = n.row * CELL_HEIGHT;
                            const noteBottom = noteTop + CELL_HEIGHT;
                            
                            // 노트가 선택 박스와 겹치는지 확인
                            if (noteRight > boxLeft && noteLeft < boxRight &&
                                noteBottom > boxTop && noteTop < boxBottom) {
                                n.selected = true;
                            }
                        });
                    }
                    
                    selectionBox.remove();
                    selectionBox = null;
                    isSelecting = false;
                    renderNotes();
                    
                    const selectedCount = t.notes.filter(n => n.selected).length;
                    if (selectedCount > 0) {
                        showToast(`${selectedCount}개 노트 선택됨`);
                    }
                    return;
                }
                
                // 노트 그리기 종료
                if (!isDrawing) return;
                isDrawing = false;
                stopSustainedNote(drawStartNote);
                
                if (previewNote && tracks[currentTrackIndex]) {
                    const beatWidth = getBeatWidth();
                    const len = Math.max(getSnapUnit(), (parseFloat(previewNote.style.width) + 2) / beatWidth);
                    const t = tracks[currentTrackIndex];
                    
                    // 겹침 체크
                    const exists = t.notes.findIndex(n => n.row === drawStartRow &&
                        ((n.beat <= drawStartBeat && n.beat + n.length > drawStartBeat) ||
                         (drawStartBeat <= n.beat && drawStartBeat + len > n.beat)));
                    
                    if (exists === -1) {
                        t.notes.push({ note: drawStartNote, row: drawStartRow, beat: drawStartBeat, length: len });
                    }
                    
                    previewNote.remove();
                    previewNote = null;
                    renderNotes();
                    updateTrackPreviews();
                }
            };

            grid.addEventListener('mousedown', startDraw);
            document.addEventListener('mousemove', moveDraw);
            document.addEventListener('mouseup', endDraw);
            grid.addEventListener('touchstart', startDraw, { passive: false });
            document.addEventListener('touchmove', moveDraw, { passive: false });
            document.addEventListener('touchend', endDraw);
        }

        function createPreviewNote(row, beat, len) {
            const grid = document.getElementById('pianoGrid');
            const beatWidth = getBeatWidth();
            
            previewNote = document.createElement('div');
            previewNote.className = 'note preview';
            previewNote.style.left = (beat * beatWidth) + 'px';
            previewNote.style.top = (row * CELL_HEIGHT + 1) + 'px';
            previewNote.style.width = (len * beatWidth - 2) + 'px';
            previewNote.style.background = tracks[currentTrackIndex]?.color || TRACK_COLORS[0];
            grid.appendChild(previewNote);
        }

        function renderNotes() {
            document.querySelectorAll('.note:not(.preview)').forEach(n => n.remove());
            const t = tracks[currentTrackIndex];
            if (!t || t.type !== 'note') return;
            const grid = document.getElementById('pianoGrid');
            const beatWidth = getBeatWidth();
            
            t.notes.forEach((n, i) => {
                const el = document.createElement('div');
                el.className = 'note' + (n.selected ? ' selected' : '');
                el.style.left = (n.beat * beatWidth) + 'px';
                el.style.top = (n.row * CELL_HEIGHT + 1) + 'px';
                el.style.width = (n.length * beatWidth - 2) + 'px';
                el.style.background = t.color;
                el.style.boxShadow = n.selected ? 
                    '0 0 0 2px #fff, 0 4px 12px ' + t.color + '88' : 
                    '0 1px 4px ' + t.color + '66';
                el.dataset.index = i;
                el.textContent = n.note;
                const resize = document.createElement('div');
                resize.className = 'note-resize';
                el.appendChild(resize);
                grid.appendChild(el);
            });
        }

        // 노트 도구 관련
        let currentNoteTool = 'pencil'; // pencil, select, eraser

        // 전역 노트 드래그 상태
        let noteDragState = {
            active: false,
            noteIndex: -1,
            isResize: false,
            startX: 0,
            startY: 0,
            startPositions: [], // {noteRef, startBeat, startRow}
            hasMoved: false,
            startLength: 0
        };

        function setupGlobalNoteInteractions() {
            const grid = document.getElementById('pianoGrid');
            
            // 노트 위에서 마우스/터치 시작
            grid.addEventListener('mousedown', handleNoteMouseDown);
            grid.addEventListener('touchstart', handleNoteTouchStart, { passive: false });
            
            // 더블클릭 삭제
            grid.addEventListener('dblclick', (e) => {
                const noteEl = e.target.closest('.note:not(.preview)');
                if (!noteEl) return;
                const idx = parseInt(noteEl.dataset.index);
                deleteNoteAtIndex(idx);
            });
            
            // 우클릭 삭제
            grid.addEventListener('contextmenu', (e) => {
                const noteEl = e.target.closest('.note:not(.preview)');
                if (!noteEl) return;
                e.preventDefault();
                const idx = parseInt(noteEl.dataset.index);
                deleteNoteAtIndex(idx);
            });
            
            // 전역 이동 및 종료
            document.addEventListener('mousemove', handleNoteMove);
            document.addEventListener('touchmove', handleNoteMove, { passive: false });
            document.addEventListener('mouseup', handleNoteEnd);
            document.addEventListener('touchend', handleNoteEnd);
        }

        function handleNoteMouseDown(e) {
            const noteEl = e.target.closest('.note:not(.preview)');
            if (!noteEl) return;
            
            const idx = parseInt(noteEl.dataset.index);
            const t = tracks[currentTrackIndex];
            if (!t || idx < 0 || idx >= t.notes.length) return;
            
            e.preventDefault();
            e.stopPropagation();
            
            const isResizeHandle = e.target.classList.contains('note-resize');
            startNoteDrag(e, idx, isResizeHandle, e.shiftKey);
        }

        function handleNoteTouchStart(e) {
            const noteEl = e.target.closest('.note:not(.preview)');
            if (!noteEl) return;
            
            const idx = parseInt(noteEl.dataset.index);
            const t = tracks[currentTrackIndex];
            if (!t || idx < 0 || idx >= t.notes.length) return;
            
            e.preventDefault();
            e.stopPropagation();
            
            const isResizeHandle = e.target.classList.contains('note-resize');
            startNoteDrag(e, idx, isResizeHandle, false);
        }

        function startNoteDrag(e, idx, isResize, shiftKey) {
            const t = tracks[currentTrackIndex];
            const noteData = t.notes[idx];
            
            // 지우개 도구: 바로 삭제
            if (currentNoteTool === 'eraser') {
                t.notes.splice(idx, 1);
                renderNotes();
                updateTrackPreviews();
                return;
            }
            
            const touch = e.touches ? e.touches[0] : e;
            
            // 현재 노트가 선택 안 되어 있으면 선택
            if (!noteData.selected) {
                if (!shiftKey) {
                    t.notes.forEach(n => n.selected = false);
                }
                noteData.selected = true;
                renderNotes();
            }
            
            // 선택된 모든 노트의 시작 위치 저장
            const startPositions = t.notes
                .filter(n => n.selected)
                .map(n => ({ noteRef: n, startBeat: n.beat, startRow: n.row }));
            
            noteDragState = {
                active: true,
                noteIndex: idx,
                isResize: isResize,
                startX: touch.clientX,
                startY: touch.clientY,
                startPositions: startPositions,
                hasMoved: false,
                startLength: noteData.length
            };
            
            if (auditionEnabled && !isResize) {
                startSustainedNote(noteData.note);
            }
        }

        function handleNoteMove(e) {
            if (!noteDragState.active) return;
            
            const touch = e.touches ? e.touches[0] : e;
            const dx = touch.clientX - noteDragState.startX;
            const dy = touch.clientY - noteDragState.startY;
            
            if (Math.abs(dx) > 3 || Math.abs(dy) > 3) {
                noteDragState.hasMoved = true;
            }
            
            if (!noteDragState.hasMoved) return;
            
            const t = tracks[currentTrackIndex];
            if (!t) return;
            
            const beatWidth = getBeatWidth();
            const snapPixels = getSnapPixels();
            const snapUnit = getSnapUnit();
            const totalBeats = getTotalBeats();
            
            if (noteDragState.isResize) {
                // 리사이즈
                const noteData = t.notes[noteDragState.noteIndex];
                if (noteData) {
                    const deltaBeats = Math.round(dx / snapPixels) * snapUnit;
                    noteData.length = Math.max(snapUnit, noteDragState.startLength + deltaBeats);
                    renderNotes();
                }
            } else {
                // 선택된 모든 노트 이동
                const deltaBeat = Math.round(dx / snapPixels) * snapUnit;
                const deltaRow = Math.round(dy / CELL_HEIGHT);
                
                noteDragState.startPositions.forEach(({ noteRef, startBeat, startRow }) => {
                    const newBeat = Math.max(0, Math.min(totalBeats - noteRef.length, startBeat + deltaBeat));
                    const newRow = Math.max(0, Math.min(totalRows - 1, startRow + deltaRow));
                    
                    noteRef.beat = newBeat;
                    if (newRow !== noteRef.row) {
                        noteRef.row = newRow;
                        const oi = Math.floor(newRow / 12), ni = 11 - (newRow % 12);
                        noteRef.note = keyNames[ni] + octaves[oi];
                    }
                });
                
                renderNotes();
            }
        }

        function handleNoteEnd(e) {
            if (!noteDragState.active) return;
            
            const t = tracks[currentTrackIndex];
            
            // 클릭만 한 경우 (움직이지 않음) - 선택 도구에서만 선택 토글
            if (!noteDragState.hasMoved && currentNoteTool === 'select' && t) {
                const noteData = t.notes[noteDragState.noteIndex];
                if (noteData && !noteDragState.isResize) {
                    // 이미 선택되어 있으면 토글 (다른 노트 해제 후)
                    const shiftKey = e.shiftKey || false;
                    if (!shiftKey) {
                        const wasSelected = noteData.selected;
                        t.notes.forEach(n => n.selected = false);
                        noteData.selected = !wasSelected;
                    } else {
                        noteData.selected = !noteData.selected;
                    }
                    renderNotes();
                }
            }
            
            noteDragState.active = false;
            noteDragState.startPositions = [];
            stopAllSustainedNotes();
            updateTrackPreviews();
        }

        function setNoteTool(tool) {
            currentNoteTool = tool;
            document.getElementById('notePencilTool').classList.toggle('active', tool === 'pencil');
            document.getElementById('noteSelectTool').classList.toggle('active', tool === 'select');
            document.getElementById('noteEraserTool').classList.toggle('active', tool === 'eraser');
            
            // 그리드 커서 변경
            const grid = document.getElementById('pianoGrid');
            if (tool === 'pencil') grid.style.cursor = 'crosshair';
            else if (tool === 'select') grid.style.cursor = 'default';
            else if (tool === 'eraser') grid.style.cursor = 'not-allowed';
        }

        // 전체 노트 선택
        function selectAllNotes() {
            const t = tracks[currentTrackIndex];
            if (!t || t.type !== 'note') return;
            t.notes.forEach(n => n.selected = true);
            renderNotes();
            showToast(`${t.notes.length}개 노트 선택됨`);
        }

        // 모든 노트 선택 해제
        function deselectAllNotes() {
            const t = tracks[currentTrackIndex];
            if (!t || !t.notes) return;
            t.notes.forEach(n => n.selected = false);
        }

        // 선택된 노트 삭제
        function deleteSelectedNotes() {
            const t = tracks[currentTrackIndex];
            if (!t || t.type !== 'note') return;
            const count = t.notes.filter(n => n.selected).length;
            if (count === 0) return;
            t.notes = t.notes.filter(n => !n.selected);
            renderNotes();
            updateTrackPreviews();
            showToast(`${count}개 노트 삭제됨`);
        }

        function deleteNoteAtIndex(i) {
            const t = tracks[currentTrackIndex];
            if (t && t.notes && i >= 0 && i < t.notes.length) {
                t.notes.splice(i, 1);
                renderNotes();
                updateTrackPreviews();
            }
        }

        function updateTrackPreviews() {
            const gridTotalWidth = getGridTotalWidth();
            const barWidth = getBarWidth();
            const beatWidth = getBeatWidth();
            
            tracks.forEach((t, ti) => {
                const c = document.querySelector(`.track-notes-preview[data-track-id="${ti}"]`);
                if (!c) return;
                const inner = c.querySelector('.track-preview-inner');
                if (!inner) return;
                
                // 기존 내용 삭제 (라이브 캔버스 제외, 녹음 중인 트랙)
                const liveCanvas = inner.querySelector('.live-preview-canvas');
                inner.innerHTML = '';
                if (liveCanvas && isRecording && ti === currentTrackIndex) {
                    inner.appendChild(liveCanvas);
                }
                
                const w = c.clientWidth, h = c.clientHeight, scale = w / gridTotalWidth;
                inner.style.width = w + 'px';
                
                // 바 라인 그리기
                for (let i = 1; i < totalBars; i++) {
                    const l = document.createElement('div');
                    l.className = 'track-bar-line';
                    l.style.left = (i * barWidth * scale) + 'px';
                    inner.appendChild(l);
                }
                
                if (t.type === 'record' && t.clips && t.clips.length > 0) {
                    // 녹음 트랙 - 클립별로 미니 파형 그리기
                    const canvas = document.createElement('canvas');
                    canvas.width = w;
                    canvas.height = h;
                    canvas.style.position = 'absolute';
                    canvas.style.top = '0';
                    canvas.style.left = '0';
                    inner.appendChild(canvas);
                    
                    const ctx = canvas.getContext('2d');
                    const pixelsPerSecond = beatWidth * bpm / 60;
                    const amp = h / 2;
                    
                    ctx.fillStyle = t.color;
                    ctx.globalAlpha = 0.8;
                    
                    t.clips.forEach(clip => {
                        if (!clip.audioBuffer) return;
                        
                        const data = clip.audioBuffer.getChannelData(0);
                        const sampleRate = clip.audioBuffer.sampleRate;
                        const clipDuration = clip.trimEnd - clip.trimStart;
                        
                        // 클립 위치와 크기 계산
                        const clipStartX = clip.startBeat * beatWidth * scale;
                        const clipWidth = clipDuration * pixelsPerSecond * scale;
                        
                        const waveBarWidth = 2;
                        const gap = 1;
                        const step = waveBarWidth + gap;
                        
                        for (let x = 0; x < clipWidth && (clipStartX + x) < w; x += step) {
                            const timeInClip = clip.trimStart + (x / clipWidth) * clipDuration;
                            const sampleIndex = Math.floor(timeInClip * sampleRate);
                            const nextTimeInClip = clip.trimStart + ((x + step) / clipWidth) * clipDuration;
                            const nextSampleIndex = Math.floor(nextTimeInClip * sampleRate);
                            const samplesInBar = Math.max(1, nextSampleIndex - sampleIndex);
                            
                            let sum = 0;
                            for (let i = 0; i < samplesInBar; i++) {
                                const idx = sampleIndex + i;
                                if (idx < data.length) {
                                    sum += Math.abs(data[idx]);
                                }
                            }
                            
                            const average = sum / samplesInBar;
                            const barHeight = Math.max(1, average * h * 1.5);
                            const y = amp - barHeight / 2;
                            
                            ctx.fillRect(clipStartX + x, y, waveBarWidth, barHeight);
                        }
                    });
                } else if (t.type === 'drum' && t.pattern) {
                    // 드럼 트랙 - 패턴 바 그리기
                    const stepsPerBeat = 4;
                    const totalSteps = totalBars * BEATS_PER_BAR * stepsPerBeat;
                    const stepWidth = w / totalSteps;
                    const kit = DRUM_KITS[t.drumKit || 'acoustic'];
                    const numRows = kit ? kit.sounds.length : 8;
                    const rowHeight = h / numRows;
                    
                    for (let rowIdx = 0; rowIdx < numRows; rowIdx++) {
                        const row = t.pattern[rowIdx];
                        if (!row) continue;
                        for (let step = 0; step < row.length; step++) {
                            if (row[step]) {
                                const b = document.createElement('div');
                                b.className = 'track-note-bar';
                                b.style.left = (step * stepWidth) + 'px';
                                b.style.top = (rowIdx * rowHeight) + 'px';
                                b.style.width = Math.max(2, stepWidth * 0.8) + 'px';
                                b.style.height = Math.max(2, rowHeight * 0.7) + 'px';
                                b.style.background = t.color;
                                inner.appendChild(b);
                            }
                        }
                    }
                } else if (t.type === 'note') {
                    // 노트 트랙 - 노트 바 그리기
                    t.notes.forEach(n => {
                        const b = document.createElement('div');
                        b.className = 'track-note-bar';
                        b.style.left = (n.beat * beatWidth * scale) + 'px';
                        b.style.top = ((n.row / totalRows) * h) + 'px';
                        b.style.width = Math.max(2, n.length * beatWidth * scale) + 'px';
                        b.style.background = t.color;
                        inner.appendChild(b);
                    });
                }
            });
        }

        function updateTrackSelection() {
            document.querySelectorAll('.audio-track').forEach((el, i) => el.classList.toggle('active', i === currentTrackIndex));
            const track = tracks[currentTrackIndex];
            const instrumentSelect = document.getElementById('instrumentSelect');
            const instrumentSelectMini = document.getElementById('instrumentSelectMini');
            const pianoRollHeader = document.getElementById('pianoRollHeader');
            
            if (!track) {
                instrumentSelect.style.display = 'none';
                pianoRollHeader.classList.remove('show');
                return;
            }
            
            // 피아노 롤 헤더는 노트 트랙에서만 표시
            if (track.type === 'note') {
                pianoRollHeader.classList.add('show');
                instrumentSelect.style.display = 'none'; // 상단 툴바의 악기 선택 숨김
                instrumentSelectMini.value = track.instrument || 'piano';
            } else {
                pianoRollHeader.classList.remove('show');
                instrumentSelect.style.display = 'none';
            }
            
            updateTrackView();
        }

        function selectTrackFromPreview(id) {
            currentTrackIndex = id;
            document.getElementById('trackSelect').value = id;
            renderNotes();
            updateTrackSelection();
        }

        function syncScroll() {
            const keys = document.getElementById('pianoKeys');
            const wrapper = document.getElementById('pianoGridWrapper');
            const timeline = document.getElementById('timelineInner');
            wrapper.addEventListener('scroll', () => {
                keys.scrollTop = wrapper.scrollTop;
                timeline.style.transform = `translateX(-${wrapper.scrollLeft}px)`;
            });
        }

        // Audio
        function initAudio() {
            if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
            audioContext.resume();
        }

        // 샘플 기반 악기 (Tone.js Sampler)
        const samplers = {};
        const loadedInstruments = new Set();
        let pianoLoaded = false;

        // Salamander Grand Piano 샘플 URL
        const PIANO_SAMPLES = {
            'A0': 'A0.mp3', 'C1': 'C1.mp3', 'D#1': 'Ds1.mp3', 'F#1': 'Fs1.mp3',
            'A1': 'A1.mp3', 'C2': 'C2.mp3', 'D#2': 'Ds2.mp3', 'F#2': 'Fs2.mp3',
            'A2': 'A2.mp3', 'C3': 'C3.mp3', 'D#3': 'Ds3.mp3', 'F#3': 'Fs3.mp3',
            'A3': 'A3.mp3', 'C4': 'C4.mp3', 'D#4': 'Ds4.mp3', 'F#4': 'Fs4.mp3',
            'A4': 'A4.mp3', 'C5': 'C5.mp3', 'D#5': 'Ds5.mp3', 'F#5': 'Fs5.mp3',
            'A5': 'A5.mp3', 'C6': 'C6.mp3', 'D#6': 'Ds6.mp3', 'F#6': 'Fs6.mp3',
            'A6': 'A6.mp3', 'C7': 'C7.mp3', 'D#7': 'Ds7.mp3', 'F#7': 'Fs7.mp3',
            'A7': 'A7.mp3', 'C8': 'C8.mp3'
        };

        // 기본 샘플 노트들 (모든 악기용)
        const SAMPLE_NOTES = ['C2', 'C3', 'C4', 'C5', 'C6'];

        // MIDI.js Soundfont 악기 매핑
        const SOUNDFONT_MAP = {
            'piano': 'acoustic_grand_piano',
            'electric-piano': 'electric_piano_1',
            'organ': 'church_organ',
            'guitar': 'acoustic_guitar_nylon',
            'acoustic-guitar': 'acoustic_guitar_nylon',
            'electric-guitar': 'electric_guitar_clean',
            'clean-guitar': 'electric_guitar_clean',
            'distortion-guitar': 'distortion_guitar',
            'bass': 'acoustic_bass',
            'electric-bass': 'electric_bass_finger',
            'slap-bass': 'slap_bass_1',
            'synth-bass': 'synth_bass_1',
            'strings': 'string_ensemble_1',
            'violin': 'violin',
            'cello': 'cello',
            'synth': 'synth_brass_1',
            'synth-lead': 'lead_1_square',
            'synth-pad': 'pad_2_warm',
            'pad': 'pad_2_warm',
            'brass': 'brass_section',
            'trumpet': 'trumpet',
            'trombone': 'trombone',
            'flute': 'flute',
            'clarinet': 'clarinet',
            'saxophone': 'alto_sax',
            'oboe': 'oboe',
            'harmonica': 'harmonica',
            'accordion': 'accordion',
            'harp': 'orchestral_harp',
            'marimba': 'marimba',
            'vibraphone': 'vibraphone',
            'xylophone': 'xylophone',
            'music-box': 'music_box',
            'bell': 'tubular_bells',
            'pluck': 'pizzicato_strings',
            'square': 'lead_1_square'
        };

        // 악기 샘플 로드
        async function loadInstrumentSampler(instrument) {
            if (loadedInstruments.has(instrument)) return samplers[instrument];
            if (samplers[instrument]) return samplers[instrument];

            const soundfontName = SOUNDFONT_MAP[instrument];
            if (!soundfontName) return null;

            try {
                await Tone.start();
                
                // 피아노는 Salamander 샘플 사용
                if (instrument === 'piano') {
                    samplers['piano'] = new Tone.Sampler({
                        urls: PIANO_SAMPLES,
                        baseUrl: 'https://tonejs.github.io/audio/salamander/',
                        onload: () => {
                            loadedInstruments.add('piano');
                            pianoLoaded = true;
                        }
                    }).toDestination();
                    await Tone.loaded();
                    return samplers['piano'];
                }

                // 다른 악기는 MIDI.js Soundfont 사용
                const baseUrl = `https://gleitz.github.io/midi-js-soundfonts/FluidR3_GM/${soundfontName}-mp3/`;
                const urls = {};
                
                // 주요 노트들만 로드 (용량 절약)
                ['C2', 'D#2', 'F#2', 'A2', 
                 'C3', 'D#3', 'F#3', 'A3',
                 'C4', 'D#4', 'F#4', 'A4',
                 'C5', 'D#5', 'F#5', 'A5',
                 'C6', 'D#6', 'F#6', 'A6'].forEach(note => {
                    const fileName = note.replace('#', 's');
                    urls[note] = `${fileName}.mp3`;
                });

                samplers[instrument] = new Tone.Sampler({
                    urls: urls,
                    baseUrl: baseUrl,
                    onload: () => {
                        loadedInstruments.add(instrument);
                        console.log(`${instrument} samples loaded`);
                    }
                }).toDestination();

                await Tone.loaded();
                return samplers[instrument];
            } catch (e) {
                console.warn(`Failed to load ${instrument} samples:`, e);
                return null;
            }
        }

        // 초기 로드 (피아노 + 자주 쓰는 악기)
        async function initSamplers() {
            try {
                await Tone.start();
                
                // 피아노 먼저 로드
                await loadInstrumentSampler('piano');
                showToast('🎹 피아노 샘플 로드 완료');
                
                // 백그라운드에서 다른 악기들 로드
                const commonInstruments = ['guitar', 'bass', 'strings', 'synth'];
                for (const inst of commonInstruments) {
                    loadInstrumentSampler(inst).then(() => {
                        console.log(`${inst} ready`);
                    });
                }
            } catch (e) {
                console.warn('Sampler init error:', e);
            }
        }

        function createInstrumentSound(freq, instrument, gainNode, duration) {
            const inst = INSTRUMENTS[instrument] || INSTRUMENTS.piano;
            const oscillators = [];
            
            // 필터 생성
            let filterNode = null;
            if (inst.filterType && inst.filterFreq) {
                filterNode = audioContext.createBiquadFilter();
                filterNode.type = inst.filterType;
                filterNode.frequency.value = inst.filterFreq;
                filterNode.Q.value = 1;
                filterNode.connect(gainNode);
                
                // 플럭 사운드: 필터 주파수 감쇠
                if (inst.pluck) {
                    const now = audioContext.currentTime;
                    filterNode.frequency.setValueAtTime(inst.filterFreq * 2, now);
                    filterNode.frequency.exponentialRampToValueAtTime(inst.filterFreq * 0.3, now + 0.15);
                }
            }
            
            const outputNode = filterNode || gainNode;
            
            // 기타용 커스텀 웨이브폼 생성
            const oscType = (inst.type === 'custom' && inst.pluck) ? 'triangle' : inst.type;
            
            inst.harmonics.forEach((harmGain, index) => {
                const osc = audioContext.createOscillator();
                const oscGain = audioContext.createGain();
                
                osc.type = oscType === 'custom' ? 'triangle' : oscType;
                let finalFreq = freq * (index + 1);
                if (inst.octaveShift) finalFreq *= Math.pow(2, inst.octaveShift);
                osc.frequency.value = finalFreq;
                
                if (inst.detuneAmount && index > 0) {
                    osc.detune.value = inst.detuneAmount * index;
                }
                
                // 플럭 사운드의 경우 약간의 랜덤 디튠 추가
                if (inst.pluck && index > 0) {
                    osc.detune.value += (Math.random() - 0.5) * 5;
                }
                
                // 바디 레조넌스 시뮬레이션 (어쿠스틱 기타)
                if (inst.bodyResonance && index === 0) {
                    const resonanceOsc = audioContext.createOscillator();
                    const resonanceGain = audioContext.createGain();
                    resonanceOsc.type = 'sine';
                    resonanceOsc.frequency.value = finalFreq * 0.5;
                    resonanceGain.gain.value = 0.03;
                    resonanceOsc.connect(resonanceGain);
                    resonanceGain.connect(outputNode);
                    oscillators.push(resonanceOsc);
                }
                
                oscGain.gain.value = harmGain * 0.12;
                osc.connect(oscGain);
                oscGain.connect(outputNode);
                oscillators.push(osc);
            });
            
            // 디스토션 효과 (일렉기타)
            if (inst.distortion && inst.distortion > 0) {
                const distortion = audioContext.createWaveShaper();
                const amount = inst.distortion * 50;
                const samples = 44100;
                const curve = new Float32Array(samples);
                for (let i = 0; i < samples; i++) {
                    const x = (i * 2) / samples - 1;
                    curve[i] = ((3 + amount) * x * 20 * (Math.PI / 180)) / (Math.PI + amount * Math.abs(x));
                }
                distortion.curve = curve;
                distortion.oversample = '2x';
            }
            
            return oscillators;
        }

        function applyEnvelope(gainNode, instrument, duration) {
            const inst = INSTRUMENTS[instrument] || INSTRUMENTS.piano;
            const now = audioContext.currentTime;
            const totalDur = (60 / bpm) * duration;
            
            const attackEnd = now + inst.attack;
            const decayEnd = attackEnd + inst.decay;
            const sustainEnd = now + totalDur - inst.release;
            const releaseEnd = now + totalDur;
            
            gainNode.gain.setValueAtTime(0, now);
            gainNode.gain.linearRampToValueAtTime(1, attackEnd);
            gainNode.gain.linearRampToValueAtTime(inst.sustain, decayEnd);
            gainNode.gain.setValueAtTime(inst.sustain, Math.max(decayEnd, sustainEnd));
            gainNode.gain.linearRampToValueAtTime(0.001, releaseEnd);
            
            return releaseEnd;
        }

        function startSustainedNote(name) {
            initAudio();
            if (activeOscillators.has(name)) return;
            
            const instrument = tracks[currentTrackIndex].instrument || 'piano';
            const masterGain = audioContext.createGain();
            masterGain.connect(audioContext.destination);
            masterGain.gain.value = 0.3;
            
            const oscillators = createInstrumentSound(noteToFreq(name), instrument, masterGain, 1);
            oscillators.forEach(osc => osc.start());
            
            activeOscillators.set(name, { oscillators, gain: masterGain });
        }

        function stopSustainedNote(name) {
            const a = activeOscillators.get(name);
            if (a) {
                a.gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);
                a.oscillators.forEach(osc => osc.stop(audioContext.currentTime + 0.1));
                activeOscillators.delete(name);
            }
        }

        function stopAllSustainedNotes() { activeOscillators.forEach((_, n) => stopSustainedNote(n)); }

        function playNotePreview(key) { key.classList.add('playing'); if (auditionEnabled) startSustainedNote(key.dataset.note); }
        function stopNotePreview(key) { key.classList.remove('playing'); stopSustainedNote(key.dataset.note); }

        async function playNoteWithSustain(name, dur, instrument) {
            initAudio();
            
            // 샘플러 사용 시도
            const sampler = samplers[instrument];
            if (sampler && loadedInstruments.has(instrument)) {
                try {
                    await Tone.start();
                    sampler.triggerAttackRelease(name, dur);
                    return;
                } catch (e) {
                    console.warn('Sample play failed, using synth:', e);
                }
            } else {
                // 샘플이 아직 안 로드되었으면 백그라운드로 로드 시작
                loadInstrumentSampler(instrument);
            }
            
            // 합성음 폴백
            const masterGain = audioContext.createGain();
            masterGain.connect(audioContext.destination);
            
            const oscillators = createInstrumentSound(noteToFreq(name), instrument, masterGain, dur);
            const endTime = applyEnvelope(masterGain, instrument, dur);
            
            oscillators.forEach(osc => {
                osc.start();
                osc.stop(endTime);
            });
        }

        function noteToFreq(name) {
            const map = { 'C':0,'C#':1,'D':2,'D#':3,'E':4,'F':5,'F#':6,'G':7,'G#':8,'A':9,'A#':10,'B':11 };
            const n = name.slice(0, -1), o = parseInt(name.slice(-1));
            return 440 * Math.pow(2, (map[n] + (o - 4) * 12 - 9) / 12);
        }

        // Metronome
        let metronomeEnabled = false;
        let lastMetronomeBeat = -1;

        function toggleMetronome() {
            metronomeEnabled = !metronomeEnabled;
            document.getElementById('metronomeBtn').classList.toggle('active', metronomeEnabled);
        }

        function playMetronomeClick(isDownbeat) {
            if (!audioContext) return;
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.connect(gain);
            gain.connect(audioContext.destination);
            
            osc.frequency.value = isDownbeat ? 1000 : 800;
            osc.type = 'sine';
            gain.gain.setValueAtTime(0.3, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.05);
            
            osc.start(audioContext.currentTime);
            osc.stop(audioContext.currentTime + 0.05);
        }

        // Copy/Paste
        let copiedNotes = [];

        function copySelectedNotes() {
            const track = tracks[currentTrackIndex];
            if (!track || track.type !== 'note') return;
            
            const selectedNotes = track.notes.filter(n => n.selected);
            if (selectedNotes.length === 0) {
                // 선택된 노트가 없으면 전체 복사
                copiedNotes = track.notes.map(n => ({...n}));
            } else {
                copiedNotes = selectedNotes.map(n => ({...n}));
            }
            
            if (copiedNotes.length > 0) {
                // 최소 startBeat 기준으로 정규화
                const minStart = Math.min(...copiedNotes.map(n => n.startBeat));
                copiedNotes = copiedNotes.map(n => ({...n, startBeat: n.startBeat - minStart}));
                showToast(`${copiedNotes.length}개 노트 복사됨`);
            }
        }

        function pasteNotes() {
            const track = tracks[currentTrackIndex];
            if (!track || track.type !== 'note' || copiedNotes.length === 0) return;
            
            // 현재 플레이헤드 위치에 붙여넣기
            const beatWidth = getBeatWidth();
            const pasteStartBeat = playheadPosition / beatWidth;
            
            copiedNotes.forEach(n => {
                const newNote = {
                    ...n,
                    id: Date.now() + Math.random(),
                    startBeat: n.startBeat + pasteStartBeat,
                    selected: false
                };
                track.notes.push(newNote);
            });
            
            renderNotes();
            updateTrackPreviews();
            showToast(`${copiedNotes.length}개 노트 붙여넣기됨`);
        }

        function showToast(message) {
            let toast = document.getElementById('toast');
            if (!toast) {
                toast = document.createElement('div');
                toast.id = 'toast';
                toast.style.cssText = 'position:fixed;bottom:80px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.8);color:#fff;padding:10px 20px;border-radius:8px;font-size:12px;z-index:9999;transition:opacity 0.3s;';
                document.body.appendChild(toast);
            }
            toast.textContent = message;
            toast.style.opacity = '1';
            setTimeout(() => { toast.style.opacity = '0'; }, 2000);
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
            
            const track = tracks[currentTrackIndex];
            const isDrumTrack = track && track.type === 'drum';
            const isNoteTrack = track && track.type === 'note';
            
            if (e.ctrlKey || e.metaKey) {
                if (e.key === 'a') { 
                    e.preventDefault(); 
                    if (isNoteTrack) selectAllNotes();
                    // 드럼은 전체 선택 생략
                }
                if (e.key === 'c') { e.preventDefault(); copySelectedNotes(); }
                if (e.key === 'v') { e.preventDefault(); pasteNotes(); }
                if (e.key === 's') { e.preventDefault(); showSaveModal(); }
            }
            if (e.key === ' ') { e.preventDefault(); togglePlay(); }
            if (e.key === 'Delete' || e.key === 'Backspace') {
                e.preventDefault();
                if (isDrumTrack) {
                    deleteSelectedDrumCells();
                } else if (isNoteTrack) {
                    deleteSelectedNotes();
                }
            }
            if (e.key === 'Escape') {
                if (isDrumTrack) {
                    clearDrumSelection();
                } else if (isNoteTrack) {
                    deselectAllNotes();
                    renderNotes();
                }
            }
            // 도구 단축키
            if (e.key === 'p' || e.key === 'P' || e.key === '1') {
                if (isDrumTrack) setDrumTool('pencil');
                else if (isNoteTrack) setNoteTool('pencil');
            }
            if ((e.key === 's' || e.key === '2') && !e.ctrlKey && !e.metaKey) {
                if (isDrumTrack) setDrumTool('select');
                else if (isNoteTrack) setNoteTool('select');
            }
            if (e.key === 'e' || e.key === 'E' || e.key === '3') {
                if (isDrumTrack) setDrumTool('eraser');
                else if (isNoteTrack) setNoteTool('eraser');
            }
        });

        // Playback
        function togglePlay() { isPlaying ? pausePlayback() : startPlayback(); }

        function startPlayback() {
            initAudio();
            isPlaying = true;
            document.getElementById('playBtn').classList.add('playing');
            document.getElementById('playIcon').textContent = '⏸';
            
            // 현재 플레이헤드 위치에서 시간(초) 계산
            const beatWidth = getBeatWidth();
            const pixelsPerSecond = beatWidth * bpm / 60;
            const currentTimeInSeconds = playheadPosition / pixelsPerSecond;
            
            startTime = audioContext.currentTime - currentTimeInSeconds;
            lastPlayedBeat = -1;
            lastMetronomeBeat = -1;
            playedNotes.clear();
            playedDrumSteps.clear();
            
            // 녹음된 오디오 트랙 재생 (클립 기반)
            const hasSolo = tracks.some(t => t.solo);
            tracks.forEach(track => {
                if (track.type === 'record' && track.clips && track.clips.length > 0) {
                    if (track.muted || (hasSolo && !track.solo)) return;
                    playRecordedAudio(track, currentTimeInSeconds);
                }
            });
            
            animatePlayhead();
        }

        function pausePlayback() {
            isPlaying = false;
            document.getElementById('playBtn').classList.remove('playing');
            document.getElementById('playIcon').textContent = '▶';
            cancelAnimationFrame(animationFrame);
            stopAllRecordedAudio();
            // 드럼 하이라이트 제거
            document.querySelectorAll('.drum-cell.playing').forEach(c => c.classList.remove('playing'));
        }

        function stopPlayback() {
            pausePlayback();
            playheadPosition = 0;
            updatePlayheadUI();
            updateTimeDisplay(0);
            playedNotes.clear();
            playedDrumSteps.clear();
            stopAllRecordedAudio();
            // 드럼 하이라이트 제거
            document.querySelectorAll('.drum-cell.playing').forEach(c => c.classList.remove('playing'));
        }

        let lastPlayedBeat = -1;
        const playedNotes = new Set();
        const playedDrumSteps = new Set();

        function animatePlayhead() {
            if (!isPlaying) return;
            const t = audioContext.currentTime - startTime;
            const beatWidth = getBeatWidth();
            const gridTotalWidth = getGridTotalWidth();
            const totalBeats = getTotalBeats();
            
            // 현재 위치 (픽셀)
            playheadPosition = (t * (bpm / 60) * beatWidth) % gridTotalWidth;
            updatePlayheadUI();
            
            // 시간 표시
            const loopDuration = (totalBeats * 60) / bpm;
            updateTimeDisplay(t % loopDuration);

            // 현재 비트 (소수점 포함)
            const currentBeat = (playheadPosition / beatWidth);
            const currentBeatFloor = Math.floor(currentBeat * 32) / 32; // 1/32 정밀도
            const currentStep = Math.floor(currentBeat * 4); // 1/16 스텝 (드럼용)
            const currentBeatInt = Math.floor(currentBeat);
            
            // 메트로놈
            if (metronomeEnabled && currentBeatInt !== lastMetronomeBeat) {
                const isDownbeat = (currentBeatInt % BEATS_PER_BAR) === 0;
                playMetronomeClick(isDownbeat);
                lastMetronomeBeat = currentBeatInt;
            }
            
            if (currentBeatFloor !== lastPlayedBeat) {
                if (currentBeatFloor < lastPlayedBeat) {
                    playedNotes.clear();
                    playedDrumSteps.clear();
                    lastMetronomeBeat = -1;
                }
                const hasSolo = tracks.some(t => t.solo);
                
                tracks.forEach((track, ti) => {
                    if (track.muted || (hasSolo && !track.solo)) return;
                    
                    // 드럼 트랙 재생
                    if (track.type === 'drum' && track.pattern) {
                        const stepKey = `${ti}-${currentStep}`;
                        if (!playedDrumSteps.has(stepKey)) {
                            const kit = DRUM_KITS[track.drumKit || 'acoustic'];
                            Object.keys(track.pattern).forEach(rowIdx => {
                                if (track.pattern[rowIdx][currentStep]) {
                                    if (kit.sounds[rowIdx]) {
                                        playDrumSound(kit.sounds[rowIdx]);
                                    }
                                }
                            });
                            playedDrumSteps.add(stepKey);
                            
                            // 드럼 그리드 시각적 피드백
                            highlightDrumStep(currentStep);
                        }
                    }
                    
                    // 노트 트랙 재생
                    if (track.type === 'note') {
                        track.notes.forEach((n, ni) => {
                            const key = `${ti}-${ni}-${n.beat}`;
                            if (n.beat >= lastPlayedBeat && n.beat < currentBeatFloor + 0.03 && !playedNotes.has(key)) {
                                playNoteWithSustain(n.note, n.length, track.instrument || 'piano');
                                playedNotes.add(key);
                            }
                        });
                    }
                });
                lastPlayedBeat = currentBeatFloor;
            }
            animationFrame = requestAnimationFrame(animatePlayhead);
        }

        function highlightDrumStep(step) {
            document.querySelectorAll('.drum-cell.playing').forEach(c => c.classList.remove('playing'));
            document.querySelectorAll(`.drum-cell[data-step="${step}"]`).forEach(c => c.classList.add('playing'));
        }

        function updatePlayheadUI() {
            document.getElementById('playhead').style.left = playheadPosition + 'px';
            const gridTotalWidth = getGridTotalWidth();
            const p = playheadPosition / gridTotalWidth;
            document.querySelectorAll('.track-playhead').forEach(ph => ph.style.left = (p * ph.parentElement.clientWidth) + 'px');
            
            // 레코드 뷰 플레이헤드
            const recordPlayhead = document.getElementById('recordPlayhead');
            if (recordPlayhead) {
                recordPlayhead.style.left = playheadPosition + 'px';
            }
            
            // 드럼 그리드 플레이헤드
            const drumPlayhead = document.getElementById('drumPlayhead');
            if (drumPlayhead) {
                const totalSteps = totalBars * BEATS_PER_BAR * 4;
                const drumCellWidth = 28;
                const drumGridWidth = totalSteps * drumCellWidth;
                const drumPosition = (playheadPosition / gridTotalWidth) * drumGridWidth;
                drumPlayhead.style.left = drumPosition + 'px';
            }
        }

        function updateTimeDisplay(s) {
            const m = Math.floor(s / 60), sec = Math.floor(s % 60);
            document.getElementById('timeDisplay').textContent = String(m).padStart(2, '0') + ':' + String(sec).padStart(2, '0');
        }

        function updateBPM() {
            bpm = Math.max(60, Math.min(200, parseInt(document.getElementById('bpmInput').value) || 120));
            document.getElementById('bpmInput').value = bpm;
        }

        document.getElementById('bpmInput').addEventListener('change', updateBPM);

        // Track management
        function addNewTrack() {
            showTrackTypeModal();
        }

        function deleteCurrentTrack() {
            if (tracks.length === 0 || currentTrackIndex < 0) return;
            document.querySelector(`.audio-track[data-track-id="${currentTrackIndex}"]`)?.remove();
            tracks.splice(currentTrackIndex, 1);
            const sel = document.getElementById('trackSelect');
            sel.innerHTML = '';
            tracks.forEach((t, i) => { const o = document.createElement('option'); o.value = i; o.textContent = t.name; sel.appendChild(o); });
            document.querySelectorAll('.audio-track').forEach((el, i) => {
                el.dataset.trackId = i;
                el.querySelector('.track-notes-preview').dataset.trackId = i;
                el.querySelector('.track-notes-preview').onclick = () => selectTrackFromPreview(i);
            });
            
            if (tracks.length === 0) {
                currentTrackIndex = -1;
            } else {
                currentTrackIndex = Math.min(currentTrackIndex, tracks.length - 1);
                sel.value = currentTrackIndex;
            }
            
            renderNotes();
            updateTrackPreviews();
            updateTrackSelection();
            updateTrackView(); // 드럼/레코드 뷰 업데이트
            updateEmptyState();
        }

        function switchTrack() {
            currentTrackIndex = parseInt(document.getElementById('trackSelect').value);
            renderNotes();
            updateTrackSelection();
        }

        function addAudioTrackUI(id) {
            const t = tracks[id];
            const instrumentOptions = Object.keys(INSTRUMENTS).map(key => 
                `<option value="${key}" ${t.instrument === key ? 'selected' : ''}>${INSTRUMENTS[key].name}</option>`
            ).join('');
            
            const trackType = t.type || 'note';
            let typeIcon = '🎹';
            let typeClass = 'note';
            let typeLabel = '';
            
            if (trackType === 'drum') {
                typeIcon = '🥁';
                typeClass = 'drum';
                typeLabel = '드럼';
            } else if (trackType === 'record') {
                typeIcon = '🎙️';
                typeClass = 'record';
                typeLabel = '오디오';
            }
            
            document.getElementById('tracksContainer').insertAdjacentHTML('beforeend', `
                <div class="audio-track" data-track-id="${id}">
                    <div class="track-info">
                        <div class="track-name-row">
                            <span class="track-type-indicator ${typeClass}">${typeIcon}</span>
                            <input type="text" class="track-name-input" value="${t.name}" maxlength="10" style="color:${t.color};">
                        </div>
                        ${trackType === 'note' ? `
                        <select class="track-instrument-select" onchange="changeTrackInstrument(${id}, this.value)">
                            ${instrumentOptions}
                        </select>
                        ` : `<div class="track-sub-label">${typeLabel}</div>`}
                        <div class="track-controls">
                            <button class="track-btn solo" onclick="toggleSolo(this,${id})">S</button>
                            <button class="track-btn mute" onclick="toggleMute(this,${id})">M</button>
                            <button class="track-btn delete" onclick="deleteAudioTrack(this)">✕</button>
                        </div>
                    </div>
                    <div class="track-notes-preview" data-track-id="${id}" onclick="selectTrackFromPreview(${id})">
                        <div class="track-preview-inner"></div>
                        <div class="track-playhead" style="left:0;"></div>
                    </div>
                </div>
            `);
            updateTrackPreviews();
        }

        function addAudioTrack() { addNewTrack(); }

        function deleteAudioTrack(btn) {
            const id = parseInt(btn.closest('.audio-track').dataset.trackId);
            currentTrackIndex = id; 
            document.getElementById('trackSelect').value = id; 
            deleteCurrentTrack();
        }

        function toggleSolo(btn, id) { tracks[id].solo = !tracks[id].solo; btn.classList.toggle('active', tracks[id].solo); }
        function toggleMute(btn, id) { tracks[id].muted = !tracks[id].muted; btn.classList.toggle('active', tracks[id].muted); }

        // Prevent zoom
        document.addEventListener('touchstart', e => { if (e.touches.length > 1) e.preventDefault(); }, { passive: false });
        let lastTouchEnd = 0;
        document.addEventListener('touchend', e => { if (Date.now() - lastTouchEnd <= 300) e.preventDefault(); lastTouchEnd = Date.now(); }, false);

        document.getElementById('modalOverlay').addEventListener('click', e => { if (e.target === document.getElementById('modalOverlay')) closeModal(); });
        window.addEventListener('resize', updateTrackPreviews);

        // Wake lock
        if ('wakeLock' in navigator) {
            let wakeLock = null;
            const requestWakeLock = async () => {
                try { wakeLock = await navigator.wakeLock.request('screen'); } catch (e) {}
            };
            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'visible' && isPlaying) requestWakeLock();
            });
        }
    </script>
</body>
</html>
